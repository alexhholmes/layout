package codegen

import (
	"strings"
	"testing"

	analyzer2 "layout/internal/analyzer"
	parser2 "layout/internal/parser"
)

// TestIntegrationSimplePage demonstrates complete code generation flow
func TestIntegrationSimplePage(t *testing.T) {
	// Simulate parsing a struct like:
	// @layout size=4096
	// type Page struct {
	//     Header uint16 `layout:"@0"`
	//     Body   []byte `layout:"start-end"`
	//     Footer uint64 `layout:"@4088"`
	// }

	layout := &parser2.TypeLayout{
		Name: "Page",
		Anno: &parser2.TypeAnnotation{Size: 4096, Endian: "little"},
		Fields: []parser2.Field{
			{
				Name:   "Header",
				GoType: "uint16",
				Layout: &parser2.FieldLayout{
					Offset:    0,
					Direction: parser2.Fixed,
				},
			},
			{
				Name:   "Body",
				GoType: "[]byte",
				Layout: &parser2.FieldLayout{
					Offset:    -1,
					Direction: parser2.StartEnd,
					StartAt:   -1,
				},
			},
			{
				Name:   "Footer",
				GoType: "uint64",
				Layout: &parser2.FieldLayout{
					Offset:    4088,
					Direction: parser2.Fixed,
				},
			},
		},
	}

	// Analyze layout
	reg := analyzer2.NewTypeRegistry()
	analyzed, err := analyzer2.Analyze(layout, reg)
	if err != nil {
		t.Fatalf("Analyze failed: %v", err)
	}

	if !analyzed.IsValid() {
		t.Fatalf("Layout invalid: %v", analyzed.Errors)
	}

	// Verify regions were calculated correctly
	if len(analyzed.Regions) != 3 {
		t.Fatalf("Expected 3 regions, got %d", len(analyzed.Regions))
	}

	// Header: [0, 2)
	if analyzed.Regions[0].Start != 0 || analyzed.Regions[0].Boundary != 2 {
		t.Errorf("Header region incorrect: [%d, %d)", analyzed.Regions[0].Start, analyzed.Regions[0].Boundary)
	}

	// Body: [2, 4088)
	if analyzed.Regions[1].Start != 2 || analyzed.Regions[1].Boundary != 4088 {
		t.Errorf("Body region incorrect: [%d, %d)", analyzed.Regions[1].Start, analyzed.Regions[1].Boundary)
	}

	// Footer: [4088, 4096)
	if analyzed.Regions[2].Start != 4088 || analyzed.Regions[2].Boundary != 4096 {
		t.Errorf("Footer region incorrect: [%d, %d)", analyzed.Regions[2].Start, analyzed.Regions[2].Boundary)
	}

	// Generate code
	gen := NewGenerator(analyzed, reg, "little")
	code, err := gen.Generate()
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Verify generated code structure
	expectedParts := []string{
		"// Code generated by layoutgen. DO NOT EDIT.",
		"package main",
		"import (",
		"\"encoding/binary\"",
		"\"fmt\"",
		"func (p *Page) MarshalLayout() ([]byte, error)",
		"buf := make([]byte, 4096)",
		// Header marshal
		"binary.LittleEndian.PutUint16(buf[0:2], p.Header)",
		// Body marshal (dynamic)
		"offset := 2",
		"for i := range p.Body",
		"if offset >= 4088",
		"buf[offset] = p.Body[i]",
		// Footer marshal
		"binary.LittleEndian.PutUint64(buf[4088:4096], p.Footer)",
		"return buf, nil",
		// Unmarshal
		"func (p *Page) UnmarshalLayout(buf []byte) error",
		"if len(buf) != 4096",
		// Header unmarshal
		"p.Header = binary.LittleEndian.Uint16(buf[0:2])",
		// Body unmarshal with buffer reuse
		"if cap(p.Body) >=",
		"p.Body = p.Body[",
		"copy(p.Body, buf[2:4088])",
		// Footer unmarshal
		"p.Footer = binary.LittleEndian.Uint64(buf[4088:4096])",
		"return nil",
	}

	for _, expected := range expectedParts {
		if !strings.Contains(code, expected) {
			t.Errorf("Generated code missing expected part: %q\n\nGenerated code:\n%s", expected, code)
		}
	}

	t.Logf("Generated code:\n%s", code)
}

// TestIntegrationWithCountField tests code generation with count field
func TestIntegrationWithCountField(t *testing.T) {
	// Simulate:
	// @layout size=4096
	// type Page struct {
	//     NumKeys uint16 `layout:"@0"`
	//     Keys    []byte `layout:"start-end,count=NumKeys"`
	// }

	layout := &parser2.TypeLayout{
		Name: "Page",
		Anno: &parser2.TypeAnnotation{Size: 4096, Endian: "little"},
		Fields: []parser2.Field{
			{
				Name:   "NumKeys",
				GoType: "uint16",
				Layout: &parser2.FieldLayout{
					Offset:    0,
					Direction: parser2.Fixed,
				},
			},
			{
				Name:   "Keys",
				GoType: "[]byte",
				Layout: &parser2.FieldLayout{
					Offset:     -1,
					Direction:  parser2.StartEnd,
					StartAt:    -1,
					CountField: "NumKeys",
				},
			},
		},
	}

	reg := analyzer2.NewTypeRegistry()
	analyzed, err := analyzer2.Analyze(layout, reg)
	if err != nil {
		t.Fatalf("Analyze failed: %v", err)
	}

	gen := NewGenerator(analyzed, reg, "little")
	code, err := gen.Generate()
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Verify count validation in marshal
	if !strings.Contains(code, "if len(p.Keys) != int(p.NumKeys)") {
		t.Error("Missing count validation in marshal")
	}

	// Verify count-based unmarshal
	if !strings.Contains(code, "if cap(p.Keys) >= int(p.NumKeys)") {
		t.Error("Missing capacity check with count field")
	}
	if !strings.Contains(code, "p.Keys = p.Keys[:p.NumKeys]") {
		t.Error("Missing buffer reuse with count")
	}

	t.Logf("Generated code:\n%s", code)
}

// TestIntegrationBackwardGrowth tests end-start (backward) generation
func TestIntegrationBackwardGrowth(t *testing.T) {
	// Simulate:
	// @layout size=4096
	// type Page struct {
	//     Header uint16 `layout:"@0"`
	//     Keys   []byte `layout:"end-start"`
	// }

	layout := &parser2.TypeLayout{
		Name: "Page",
		Anno: &parser2.TypeAnnotation{Size: 4096, Endian: "little"},
		Fields: []parser2.Field{
			{
				Name:   "Header",
				GoType: "uint16",
				Layout: &parser2.FieldLayout{
					Offset:    0,
					Direction: parser2.Fixed,
				},
			},
			{
				Name:   "Keys",
				GoType: "[]byte",
				Layout: &parser2.FieldLayout{
					Offset:    -1,
					Direction: parser2.EndStart,
					StartAt:   -1,
				},
			},
		},
	}

	reg := analyzer2.NewTypeRegistry()
	analyzed, err := analyzer2.Analyze(layout, reg)
	if err != nil {
		t.Fatalf("Analyze failed: %v", err)
	}

	// Verify backward growth region
	if len(analyzed.Regions) != 2 {
		t.Fatalf("Expected 2 regions, got %d", len(analyzed.Regions))
	}
	keysRegion := analyzed.Regions[1]
	if keysRegion.Start != 4096 {
		t.Errorf("Keys should start at 4096, got %d", keysRegion.Start)
	}
	if keysRegion.Boundary != 2 {
		t.Errorf("Keys boundary should be 2, got %d", keysRegion.Boundary)
	}

	gen := NewGenerator(analyzed, reg, "little")
	code, err := gen.Generate()
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Verify backward iteration
	if !strings.Contains(code, "for i := len(p.Keys) - 1; i >= 0; i--") {
		t.Error("Missing backward iteration")
	}
	if !strings.Contains(code, "offset--") {
		t.Error("Missing offset decrement")
	}
	if !strings.Contains(code, "if offset < 2") {
		t.Error("Missing collision check for backward growth")
	}

	t.Logf("Generated code:\n%s", code)
}
