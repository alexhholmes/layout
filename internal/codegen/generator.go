package codegen

import (
	"fmt"
	"strings"

	"github.com/alexhholmes/layout/internal/analyzer"
	"github.com/alexhholmes/layout/internal/parser"
)

// Generator generates marshal/unmarshal code for binary layouts
type Generator struct {
	analyzed   *analyzer.AnalyzedLayout
	layout     *parser.TypeLayout   // Original parsed layout (for indirect slices)
	allLayouts []*parser.TypeLayout // All parsed layouts (for type lookups)
	registry   *analyzer.TypeRegistry
	endian     string // "little" or "big"
	mode       string // "copy" or "zerocopy"
	align      int    // alignment requirement (0 = none)
	allocator  string // custom allocator function name (optional)
}

// typeEmitter holds marshal/unmarshal code generators for a type
type typeEmitter struct {
	marshal   func(ctx emitCtx) string
	unmarshal func(ctx emitCtx) string
}

// emitCtx carries context for code emission
type emitCtx struct {
	field      string
	start, end int
	needsCast  bool
	origType   string
}

// NewGenerator creates a new code generator
func NewGenerator(analyzed *analyzer.AnalyzedLayout, layout *parser.TypeLayout, allLayouts []*parser.TypeLayout, reg *analyzer.TypeRegistry, endian string, mode string, align int, allocator string) *Generator {
	if endian == "" {
		endian = "little"
	}
	if mode == "" {
		mode = "copy"
	}
	return &Generator{
		analyzed:   analyzed,
		layout:     layout,
		allLayouts: allLayouts,
		registry:   reg,
		endian:     endian,
		mode:       mode,
		align:      align,
		allocator:  allocator,
	}
}

// needsFmt returns true if zerocopy mode requires fmt package
func (g *Generator) needsFmt() bool {
	// Custom allocator needs fmt.Sprintf for panic
	if g.allocator != "" {
		return true
	}

	// Check regions for complex types that need error handling
	for _, region := range g.analyzed.Regions {
		resolvedType := g.registry.ResolveType(region.Field.GoType)

		// Struct fields need fmt.Errorf
		if region.Kind == analyzer.FixedRegion {
			// Check if it's a struct type (not primitive, not []byte array)
			if !strings.HasPrefix(resolvedType, "[") &&
				resolvedType != "uint8" && resolvedType != "int8" && resolvedType != "byte" &&
				resolvedType != "uint16" && resolvedType != "int16" &&
				resolvedType != "uint32" && resolvedType != "int32" &&
				resolvedType != "uint64" && resolvedType != "int64" {
				return true
			}
		}

		// Dynamic struct slices need fmt.Errorf
		if region.Kind == analyzer.DynamicRegion && region.ElementType != "byte" && region.ElementType != "" {
			return true
		}
	}

	return false
}

// Generate returns the complete generated file content
func (g *Generator) Generate() (string, error) {
	var out strings.Builder

	// Package comment
	out.WriteString("// Code generated by layout. DO NOT EDIT.\n\n")
	out.WriteString("package main\n\n")

	// Imports
	out.WriteString("import (\n")
	if g.mode != "zerocopy" {
		out.WriteString("\t\"encoding/binary\"\n")
		out.WriteString("\t\"fmt\"\n")
	}
	if g.mode == "zerocopy" {
		if g.needsFmt() {
			out.WriteString("\t\"fmt\"\n")
		}
		out.WriteString("\t\"io\"\n")
		out.WriteString("\t\"unsafe\"\n")
	}
	out.WriteString(")\n\n")

	// Generate marshal method
	marshal := g.GenerateMarshal()
	out.WriteString(marshal)
	out.WriteString("\n")

	// Generate unmarshal method
	unmarshal := g.GenerateUnmarshal()
	out.WriteString(unmarshal)

	return out.String(), nil
}

// GenerateMarshal generates the MarshalLayout method
func (g *Generator) GenerateMarshal() string {
	if g.mode == "zerocopy" {
		return g.generateZeroCopyMarshal()
	}
	return g.generateCopyMarshal()
}

// generateCopyMarshal generates copy-mode marshal (existing behavior)
func (g *Generator) generateCopyMarshal() string {
	var code strings.Builder

	// Function signature
	code.WriteString(fmt.Sprintf("func (p *%s) MarshalLayout() ([]byte, error) {\n", g.analyzed.TypeName))
	code.WriteString(fmt.Sprintf("\tbuf := make([]byte, %d)\n", g.analyzed.BufferSize))

	// Declare offset only if we have dynamic regions or indirect slices
	hasDynamic := false
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.DynamicRegion {
			hasDynamic = true
			break
		}
	}
	if !hasDynamic && g.layout != nil {
		for _, field := range g.layout.Fields {
			if field.Layout.From != "" {
				hasDynamic = true
				break
			}
		}
	}
	if hasDynamic {
		code.WriteString("\tvar offset int\n")
	}
	code.WriteString("\n")

	// Generate code for each region
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.FixedRegion {
			code.WriteString(g.generateFixedOp(region, "marshal"))
		} else {
			code.WriteString(g.generateDynamicMarshal(region))
		}
	}

	// Generate indirect slice marshal ([][]byte with metadata indirection)
	if g.layout != nil {
		for _, field := range g.layout.Fields {
			if field.Layout.From != "" {
				code.WriteString(g.generateIndirectMarshal(field))
			}
		}
	}

	code.WriteString("\treturn buf, nil\n")
	code.WriteString("}\n")

	return code.String()
}

// generateZeroCopyMarshal generates zero-copy marshal that writes to p.buf
func (g *Generator) generateZeroCopyMarshal() string {
	var code strings.Builder

	// Generate New function if alignment required (at top)
	if g.align > 0 {
		code.WriteString(g.generateNewFunction())
		code.WriteString("\n")
	}

	code.WriteString(fmt.Sprintf("func (p *%s) MarshalLayout() ([]byte, error) {\n", g.analyzed.TypeName))

	// Generate code for each region, writing to p.buf
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.FixedRegion {
			code.WriteString(g.generateFixedOp(region, "marshal"))
		} else {
			code.WriteString(g.generateZeroCopyDynamicMarshal(region))
		}
	}

	code.WriteString("\treturn p.buf[:], nil\n")
	code.WriteString("}\n")

	return code.String()
}

// GenerateUnmarshal generates the UnmarshalLayout method
func (g *Generator) GenerateUnmarshal() string {
	if g.mode == "zerocopy" {
		return g.generateZeroCopyUnmarshal()
	}
	return g.generateCopyUnmarshal()
}

// generateCopyUnmarshal generates copy-mode unmarshal (existing behavior)
func (g *Generator) generateCopyUnmarshal() string {
	var code strings.Builder

	// Function signature
	code.WriteString(fmt.Sprintf("func (p *%s) UnmarshalLayout(buf []byte) error {\n", g.analyzed.TypeName))

	// Buffer size check
	code.WriteString(fmt.Sprintf("\tif len(buf) != %d {\n", g.analyzed.BufferSize))
	code.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"expected %d bytes, got %%d\", len(buf))\n", g.analyzed.BufferSize))
	code.WriteString("\t}\n\n")

	// Generate code for each region
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.FixedRegion {
			code.WriteString(g.generateFixedOp(region, "unmarshal"))
		} else {
			code.WriteString(g.generateDynamicUnmarshal(region))
		}
	}

	// Generate indirect slice unmarshal ([][]byte with metadata indirection)
	if g.layout != nil {
		for _, field := range g.layout.Fields {
			if field.Layout.From != "" {
				code.WriteString(g.generateIndirectUnmarshal(field))
			}
		}
	}

	code.WriteString("\treturn nil\n")
	code.WriteString("}\n")

	return code.String()
}

// generateZeroCopyUnmarshal generates zero-copy unmarshal using unsafe pointers
func (g *Generator) generateZeroCopyUnmarshal() string {
	var code strings.Builder

	// UnmarshalLayout: keep buf parameter for backward compatibility, but use p.buf
	code.WriteString(fmt.Sprintf("func (p *%s) UnmarshalLayout(buf []byte) error {\n", g.analyzed.TypeName))
	code.WriteString(fmt.Sprintf("\t// Zero-copy mode: copy buf into p.buf if different\n"))
	code.WriteString("\tif len(buf) > 0 && len(p.buf) > 0 {\n")
	code.WriteString("\t\tif &buf[0] != &p.buf[0] {\n")
	code.WriteString("\t\t\tcopy(p.buf, buf)\n")
	code.WriteString("\t\t}\n")
	code.WriteString("\t}\n\n")

	// Generate code for each region
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.FixedRegion {
			code.WriteString(g.generateFixedOp(region, "unmarshal"))
		} else {
			code.WriteString(g.generateZeroCopyDynamicUnmarshal(region))
		}
	}

	// Rebuild indirect slices from metadata
	if g.layout != nil {
		for _, field := range g.layout.Fields {
			if field.Layout.From != "" {
				code.WriteString(g.generateIndirectUnmarshal(field))
			}
		}
	}

	code.WriteString("\treturn nil\n")
	code.WriteString("}\n\n")

	// Add LoadFrom helper
	code.WriteString(g.generateLoadFromHelper())

	// Add RebuildIndirectSlices helper if there are indirect slices
	if g.layout != nil {
		hasIndirect := false
		for _, field := range g.layout.Fields {
			if field.Layout.From != "" {
				hasIndirect = true
				break
			}
		}
		if hasIndirect {
			code.WriteString(g.generateRebuildIndirectSlices())
		}
	}

	return code.String()
}

// generateNewFunction generates New<TypeName>() constructor for aligned buffer allocation
func (g *Generator) generateNewFunction() string {
	var code strings.Builder
	requiredSize := g.analyzed.BufferSize + g.align - 1

	code.WriteString(fmt.Sprintf("func New%s() *%s {\n", g.analyzed.TypeName, g.analyzed.TypeName))
	code.WriteString(fmt.Sprintf("\tp := &%s{}\n", g.analyzed.TypeName))

	if g.allocator != "" {
		// Custom allocator with validation
		code.WriteString(fmt.Sprintf("\t// IMPORTANT: %s() must return a buffer of at least %d bytes\n", g.allocator, requiredSize))
		code.WriteString(fmt.Sprintf("\t// (%d bytes for data + %d bytes for %d-byte alignment)\n",
			g.analyzed.BufferSize, g.align-1, g.align))
		code.WriteString(fmt.Sprintf("\tp.backing = %s()\n", g.allocator))
		code.WriteString("\t\n")
		code.WriteString("\t// Validate buffer size to prevent out-of-bounds access\n")
		code.WriteString(fmt.Sprintf("\tif len(p.backing) < %d {\n", requiredSize))
		code.WriteString(fmt.Sprintf("\t\tpanic(fmt.Sprintf(\"%s returned buffer of %%d bytes, need at least %d\", len(p.backing)))\n",
			g.allocator, requiredSize))
		code.WriteString("\t}\n")
	} else {
		// Default allocation
		code.WriteString(fmt.Sprintf("\t// Allocate %d + %d to guarantee %d-byte alignment\n",
			g.analyzed.BufferSize, g.align-1, g.align))
		code.WriteString(fmt.Sprintf("\tp.backing = make([]byte, %d)\n", requiredSize))
	}

	code.WriteString("\t\n")
	code.WriteString(fmt.Sprintf("\t// Find %d-byte aligned offset\n", g.align))
	code.WriteString("\taddr := uintptr(unsafe.Pointer(&p.backing[0]))\n")
	code.WriteString(fmt.Sprintf("\toffset := int(((addr + %d) &^ %d) - addr)\n", g.align-1, g.align-1))
	code.WriteString("\t\n")
	code.WriteString("\t// Slice aligned region\n")
	code.WriteString(fmt.Sprintf("\tp.buf = p.backing[offset : offset+%d]\n", g.analyzed.BufferSize))

	// Initialize dynamic []byte fields with len=0, cap=max
	code.WriteString("\t\n")
	code.WriteString("\t// Initialize dynamic slices\n")
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.DynamicRegion && region.Field.GoType == "[]byte" {
			start := region.Start
			boundary := region.Boundary

			if region.Direction == parser.StartEnd {
				// Forward: p.Field = p.buf[start:start:boundary]
				code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d:%d:%d]\n",
					region.Field.Name, start, start, boundary))
			} else {
				// Backward (end-start): don't initialize, will be set during unmarshal
				// These regions are packed backward during marshal, not appendable
				code.WriteString(fmt.Sprintf("\t// %s: end-start region, initialized during unmarshal\n",
					region.Field.Name))
			}
		}
	}

	code.WriteString("\treturn p\n")
	code.WriteString("}\n")

	return code.String()
}

// generateLoadFromHelper generates LoadFrom and WriteTo helpers for zerocopy mode
func (g *Generator) generateLoadFromHelper() string {
	var code strings.Builder

	// LoadFrom: read from io.Reader into p.buf
	code.WriteString(fmt.Sprintf("func (p *%s) LoadFrom(r io.Reader) error {\n", g.analyzed.TypeName))
	code.WriteString("\tif _, err := io.ReadFull(r, p.buf[:]); err != nil {\n")
	code.WriteString("\t\treturn err\n")
	code.WriteString("\t}\n")
	code.WriteString("\treturn p.UnmarshalLayout(p.buf)\n")
	code.WriteString("}\n\n")

	// WriteTo: marshal and write p.buf to io.Writer
	code.WriteString(fmt.Sprintf("func (p *%s) WriteTo(w io.Writer) error {\n", g.analyzed.TypeName))
	code.WriteString("\tif _, err := p.MarshalLayout(); err != nil {\n")
	code.WriteString("\t\treturn err\n")
	code.WriteString("\t}\n")
	code.WriteString("\t_, err := w.Write(p.buf[:])\n")
	code.WriteString("\treturn err\n")
	code.WriteString("}\n")

	return code.String()
}

// binaryPutFunc returns the binary.PutXXX function name for a type
func (g *Generator) binaryPutFunc(goType string) string {
	// Resolve type aliases
	resolved := g.registry.ResolveType(goType)

	switch resolved {
	case "uint16":
		return "PutUint16"
	case "uint32":
		return "PutUint32"
	case "uint64":
		return "PutUint64"
	case "int16":
		return "PutUint16"
	case "int32":
		return "PutUint32"
	case "int64":
		return "PutUint64"
	default:
		return "PutUint32" // fallback
	}
}

// binaryGetFunc returns the binary.Uint32() function name for a type
func (g *Generator) binaryGetFunc(goType string) string {
	// Resolve type aliases
	resolved := g.registry.ResolveType(goType)

	switch resolved {
	case "uint16":
		return "Uint16"
	case "uint32":
		return "Uint32"
	case "uint64":
		return "Uint64"
	case "int16":
		return "Uint16"
	case "int32":
		return "Uint32"
	case "int64":
		return "Uint64"
	default:
		return "Uint32" // fallback
	}
}

// endianPrefix returns "binary.LittleEndian" or "binary.BigEndian"
func (g *Generator) endianPrefix() string {
	if g.endian == "big" {
		return "binary.BigEndian"
	}
	return "binary.LittleEndian"
}

// emitters returns type-specific code generators based on mode
func (g *Generator) emitters() map[string]typeEmitter {
	if g.mode == "zerocopy" {
		return map[string]typeEmitter{
			"uint8": {
				marshal: func(c emitCtx) string {
					cast := "p." + c.field
					if c.needsCast {
						cast = "byte(" + cast + ")"
					}
					return fmt.Sprintf("\tp.buf[%d] = %s\n\n", c.start, cast)
				},
				unmarshal: func(c emitCtx) string {
					cast := ""
					suffix := ""
					if c.needsCast {
						cast = c.origType + "("
						suffix = ")"
					}
					return fmt.Sprintf("\tp.%s = %sp.buf[%d]%s\n\n", c.field, cast, c.start, suffix)
				},
			},
			"byte": {
				marshal: func(c emitCtx) string {
					return fmt.Sprintf("\tp.buf[%d] = p.%s\n\n", c.start, c.field)
				},
				unmarshal: func(c emitCtx) string {
					return fmt.Sprintf("\tp.%s = p.buf[%d]\n\n", c.field, c.start)
				},
			},
			"int8": {
				marshal: func(c emitCtx) string {
					cast := "p." + c.field
					if c.needsCast {
						cast = "int8(" + cast + ")"
					}
					return fmt.Sprintf("\tp.buf[%d] = byte(%s)\n\n", c.start, cast)
				},
				unmarshal: func(c emitCtx) string {
					cast := ""
					suffix := ""
					if c.needsCast {
						cast = c.origType + "("
						suffix = ")"
					}
					return fmt.Sprintf("\tp.%s = %sint8(p.buf[%d])%s\n\n", c.field, cast, c.start, suffix)
				},
			},
			"uint16": {
				marshal: func(c emitCtx) string {
					cast := ""
					suffix := ""
					if c.needsCast {
						cast = "uint16("
						suffix = ")"
					}
					return fmt.Sprintf("\t*(*uint16)(unsafe.Pointer(&p.buf[%d])) = %sp.%s%s\n\n",
						c.start, cast, c.field, suffix)
				},
				unmarshal: func(c emitCtx) string {
					cast := ""
					suffix := ""
					if c.needsCast {
						cast = c.origType + "("
						suffix = ")"
					}
					return fmt.Sprintf("\tp.%s = %s*(*uint16)(unsafe.Pointer(&p.buf[%d]))%s\n\n",
						c.field, cast, c.start, suffix)
				},
			},
			"int16": {
				marshal: func(c emitCtx) string {
					cast := ""
					suffix := ""
					if c.needsCast {
						cast = "int16("
						suffix = ")"
					}
					return fmt.Sprintf("\t*(*int16)(unsafe.Pointer(&p.buf[%d])) = %sp.%s%s\n\n",
						c.start, cast, c.field, suffix)
				},
				unmarshal: func(c emitCtx) string {
					cast := ""
					suffix := ""
					if c.needsCast {
						cast = c.origType + "("
						suffix = ")"
					}
					return fmt.Sprintf("\tp.%s = %s*(*int16)(unsafe.Pointer(&p.buf[%d]))%s\n\n",
						c.field, cast, c.start, suffix)
				},
			},
			"uint32": {
				marshal: func(c emitCtx) string {
					cast := ""
					suffix := ""
					if c.needsCast {
						cast = "uint32("
						suffix = ")"
					}
					return fmt.Sprintf("\t*(*uint32)(unsafe.Pointer(&p.buf[%d])) = %sp.%s%s\n\n",
						c.start, cast, c.field, suffix)
				},
				unmarshal: func(c emitCtx) string {
					cast := ""
					suffix := ""
					if c.needsCast {
						cast = c.origType + "("
						suffix = ")"
					}
					return fmt.Sprintf("\tp.%s = %s*(*uint32)(unsafe.Pointer(&p.buf[%d]))%s\n\n",
						c.field, cast, c.start, suffix)
				},
			},
			"int32": {
				marshal: func(c emitCtx) string {
					cast := ""
					suffix := ""
					if c.needsCast {
						cast = "int32("
						suffix = ")"
					}
					return fmt.Sprintf("\t*(*int32)(unsafe.Pointer(&p.buf[%d])) = %sp.%s%s\n\n",
						c.start, cast, c.field, suffix)
				},
				unmarshal: func(c emitCtx) string {
					cast := ""
					suffix := ""
					if c.needsCast {
						cast = c.origType + "("
						suffix = ")"
					}
					return fmt.Sprintf("\tp.%s = %s*(*int32)(unsafe.Pointer(&p.buf[%d]))%s\n\n",
						c.field, cast, c.start, suffix)
				},
			},
			"uint64": {
				marshal: func(c emitCtx) string {
					cast := ""
					suffix := ""
					if c.needsCast {
						cast = "uint64("
						suffix = ")"
					}
					return fmt.Sprintf("\t*(*uint64)(unsafe.Pointer(&p.buf[%d])) = %sp.%s%s\n\n",
						c.start, cast, c.field, suffix)
				},
				unmarshal: func(c emitCtx) string {
					cast := ""
					suffix := ""
					if c.needsCast {
						cast = c.origType + "("
						suffix = ")"
					}
					return fmt.Sprintf("\tp.%s = %s*(*uint64)(unsafe.Pointer(&p.buf[%d]))%s\n\n",
						c.field, cast, c.start, suffix)
				},
			},
			"int64": {
				marshal: func(c emitCtx) string {
					cast := ""
					suffix := ""
					if c.needsCast {
						cast = "int64("
						suffix = ")"
					}
					return fmt.Sprintf("\t*(*int64)(unsafe.Pointer(&p.buf[%d])) = %sp.%s%s\n\n",
						c.start, cast, c.field, suffix)
				},
				unmarshal: func(c emitCtx) string {
					cast := ""
					suffix := ""
					if c.needsCast {
						cast = c.origType + "("
						suffix = ")"
					}
					return fmt.Sprintf("\tp.%s = %s*(*int64)(unsafe.Pointer(&p.buf[%d]))%s\n\n",
						c.field, cast, c.start, suffix)
				},
			},
		}
	}

	// Copy mode
	return map[string]typeEmitter{
		"uint8": {
			marshal: func(c emitCtx) string {
				fieldExpr := "p." + c.field
				if c.needsCast {
					fieldExpr = "uint8(" + fieldExpr + ")"
				}
				return fmt.Sprintf("\tbuf[%d] = %s\n\n", c.start, fieldExpr)
			},
			unmarshal: func(c emitCtx) string {
				cast := ""
				suffix := ""
				if c.needsCast {
					cast = c.origType + "("
					suffix = ")"
				}
				return fmt.Sprintf("\tp.%s = %sbuf[%d]%s\n\n", c.field, cast, c.start, suffix)
			},
		},
		"byte": {
			marshal: func(c emitCtx) string {
				return fmt.Sprintf("\tbuf[%d] = p.%s\n\n", c.start, c.field)
			},
			unmarshal: func(c emitCtx) string {
				return fmt.Sprintf("\tp.%s = buf[%d]\n\n", c.field, c.start)
			},
		},
		"int8": {
			marshal: func(c emitCtx) string {
				fieldExpr := "p." + c.field
				if c.needsCast {
					fieldExpr = "int8(" + fieldExpr + ")"
				}
				return fmt.Sprintf("\tbuf[%d] = byte(%s)\n\n", c.start, fieldExpr)
			},
			unmarshal: func(c emitCtx) string {
				cast := ""
				suffix := ""
				if c.needsCast {
					cast = c.origType + "("
					suffix = ")"
				}
				return fmt.Sprintf("\tp.%s = %sint8(buf[%d])%s\n\n", c.field, cast, c.start, suffix)
			},
		},
		"uint16": {
			marshal: func(c emitCtx) string {
				fieldExpr := "p." + c.field
				if c.needsCast {
					fieldExpr = "uint16(" + fieldExpr + ")"
				}
				return fmt.Sprintf("\t%s.PutUint16(buf[%d:%d], %s)\n\n",
					g.endianPrefix(), c.start, c.end, fieldExpr)
			},
			unmarshal: func(c emitCtx) string {
				cast := ""
				suffix := ""
				if c.needsCast {
					cast = c.origType + "("
					suffix = ")"
				}
				return fmt.Sprintf("\tp.%s = %s%s.Uint16(buf[%d:%d])%s\n\n",
					c.field, cast, g.endianPrefix(), c.start, c.end, suffix)
			},
		},
		"int16": {
			marshal: func(c emitCtx) string {
				fieldExpr := "p." + c.field
				if c.needsCast {
					fieldExpr = "int16(" + fieldExpr + ")"
				}
				return fmt.Sprintf("\t%s.PutUint16(buf[%d:%d], uint16(%s))\n\n",
					g.endianPrefix(), c.start, c.end, fieldExpr)
			},
			unmarshal: func(c emitCtx) string {
				cast := ""
				suffix := ""
				if c.needsCast {
					cast = c.origType + "("
					suffix = ")"
				}
				return fmt.Sprintf("\tp.%s = %sint16(%s.Uint16(buf[%d:%d]))%s\n\n",
					c.field, cast, g.endianPrefix(), c.start, c.end, suffix)
			},
		},
		"uint32": {
			marshal: func(c emitCtx) string {
				fieldExpr := "p." + c.field
				if c.needsCast {
					fieldExpr = "uint32(" + fieldExpr + ")"
				}
				return fmt.Sprintf("\t%s.PutUint32(buf[%d:%d], %s)\n\n",
					g.endianPrefix(), c.start, c.end, fieldExpr)
			},
			unmarshal: func(c emitCtx) string {
				cast := ""
				suffix := ""
				if c.needsCast {
					cast = c.origType + "("
					suffix = ")"
				}
				return fmt.Sprintf("\tp.%s = %s%s.Uint32(buf[%d:%d])%s\n\n",
					c.field, cast, g.endianPrefix(), c.start, c.end, suffix)
			},
		},
		"int32": {
			marshal: func(c emitCtx) string {
				fieldExpr := "p." + c.field
				if c.needsCast {
					fieldExpr = "int32(" + fieldExpr + ")"
				}
				return fmt.Sprintf("\t%s.PutUint32(buf[%d:%d], uint32(%s))\n\n",
					g.endianPrefix(), c.start, c.end, fieldExpr)
			},
			unmarshal: func(c emitCtx) string {
				cast := ""
				suffix := ""
				if c.needsCast {
					cast = c.origType + "("
					suffix = ")"
				}
				return fmt.Sprintf("\tp.%s = %sint32(%s.Uint32(buf[%d:%d]))%s\n\n",
					c.field, cast, g.endianPrefix(), c.start, c.end, suffix)
			},
		},
		"uint64": {
			marshal: func(c emitCtx) string {
				fieldExpr := "p." + c.field
				if c.needsCast {
					fieldExpr = "uint64(" + fieldExpr + ")"
				}
				return fmt.Sprintf("\t%s.PutUint64(buf[%d:%d], %s)\n\n",
					g.endianPrefix(), c.start, c.end, fieldExpr)
			},
			unmarshal: func(c emitCtx) string {
				cast := ""
				suffix := ""
				if c.needsCast {
					cast = c.origType + "("
					suffix = ")"
				}
				return fmt.Sprintf("\tp.%s = %s%s.Uint64(buf[%d:%d])%s\n\n",
					c.field, cast, g.endianPrefix(), c.start, c.end, suffix)
			},
		},
		"int64": {
			marshal: func(c emitCtx) string {
				fieldExpr := "p." + c.field
				if c.needsCast {
					fieldExpr = "int64(" + fieldExpr + ")"
				}
				return fmt.Sprintf("\t%s.PutUint64(buf[%d:%d], uint64(%s))\n\n",
					g.endianPrefix(), c.start, c.end, fieldExpr)
			},
			unmarshal: func(c emitCtx) string {
				cast := ""
				suffix := ""
				if c.needsCast {
					cast = c.origType + "("
					suffix = ")"
				}
				return fmt.Sprintf("\tp.%s = %sint64(%s.Uint64(buf[%d:%d]))%s\n\n",
					c.field, cast, g.endianPrefix(), c.start, c.end, suffix)
			},
		},
	}
}

// generateFixedOp generates marshal/unmarshal code for fixed-size field using emission table
func (g *Generator) generateFixedOp(region analyzer.Region, op string) string {
	field := region.Field
	resolvedType := g.registry.ResolveType(field.GoType)
	needsCast := resolvedType != field.GoType

	// Try primitive emitter first
	emitter, ok := g.emitters()[resolvedType]
	if ok {
		ctx := emitCtx{
			field:     field.Name,
			start:     region.Start,
			end:       region.Boundary,
			needsCast: needsCast,
			origType:  field.GoType,
		}

		code := fmt.Sprintf("\t// %s: %s at [%d, %d)\n", field.Name, field.GoType, ctx.start, ctx.end)
		switch op {
		case "marshal":
			code += emitter.marshal(ctx)
		case "unmarshal":
			code += emitter.unmarshal(ctx)
		}
		return code
	}

	// Handle complex types (arrays, structs)
	return g.generateComplexFixedOp(region, op)
}

// generateComplexFixedOp handles arrays and struct types
func (g *Generator) generateComplexFixedOp(region analyzer.Region, op string) string {
	var code strings.Builder
	field := region.Field
	start := region.Start
	end := region.Boundary

	code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n", field.Name, field.GoType, start, end))

	// Byte arrays
	if strings.HasPrefix(field.GoType, "[") && strings.Contains(field.GoType, "]byte") {
		if op == "marshal" {
			if g.mode == "zerocopy" {
				code.WriteString(fmt.Sprintf("\tcopy(p.buf[%d:%d], p.%s[:])\n\n", start, end, field.Name))
			} else {
				code.WriteString(fmt.Sprintf("\tcopy(buf[%d:%d], p.%s[:])\n\n", start, end, field.Name))
			}
		} else {
			if g.mode == "zerocopy" {
				code.WriteString(fmt.Sprintf("\tcopy(p.%s[:], p.buf[%d:%d])\n\n", field.Name, start, end))
			} else {
				code.WriteString(fmt.Sprintf("\tcopy(p.%s[:], buf[%d:%d])\n\n", field.Name, start, end))
			}
		}
		return code.String()
	}

	// Struct types
	if op == "marshal" {
		code.WriteString(fmt.Sprintf("\telemBuf, err := p.%s.MarshalLayout()\n", field.Name))
		code.WriteString("\tif err != nil {\n")
		code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"marshal %s: %%w\", err)\n", field.Name))
		code.WriteString("\t}\n")
		if g.mode == "zerocopy" {
			code.WriteString(fmt.Sprintf("\tcopy(p.buf[%d:%d], elemBuf)\n\n", start, end))
		} else {
			code.WriteString(fmt.Sprintf("\tcopy(buf[%d:%d], elemBuf)\n\n", start, end))
		}
	} else {
		if g.mode == "zerocopy" {
			code.WriteString(fmt.Sprintf("\tif err := p.%s.UnmarshalLayout(p.buf[%d:%d]); err != nil {\n", field.Name, start, end))
		} else {
			code.WriteString(fmt.Sprintf("\tif err := p.%s.UnmarshalLayout(buf[%d:%d]); err != nil {\n", field.Name, start, end))
		}
		code.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"unmarshal %s: %%w\", err)\n", field.Name))
		code.WriteString("\t}\n\n")
	}

	return code.String()
}

// generateDynamicMarshal generates marshal code for a dynamic field
func (g *Generator) generateDynamicMarshal(region analyzer.Region) string {
	// Check element type to determine marshal strategy
	if region.ElementType == "byte" {
		return g.generateByteMarshal(region)
	}
	return g.generateStructMarshal(region)
}

// generateByteMarshal generates byte-by-byte marshal for []byte
func (g *Generator) generateByteMarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s\n",
			field.Name, field.GoType, start, boundary, countField))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n",
			field.Name, field.GoType, start, boundary))
	}

	if region.Direction == parser.StartEnd {
		// Forward growth
		code.WriteString(fmt.Sprintf("\toffset = %d\n", start))

		// Count validation if count field exists
		if countField != "" {
			code.WriteString(fmt.Sprintf("\tif len(p.%s) != int(p.%s) {\n", field.Name, countField))
			code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"%s length mismatch: have %%d, want %%d\", len(p.%s), p.%s)\n",
				field.Name, field.Name, countField))
			code.WriteString("\t}\n")
		}

		// Marshal loop
		code.WriteString(fmt.Sprintf("\tfor i := range p.%s {\n", field.Name))
		code.WriteString(fmt.Sprintf("\t\tif offset >= %d {\n", boundary))
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"%s collision at offset %%d\", offset)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tbuf[offset] = p.%s[i]\n", field.Name))
		code.WriteString("\t\toffset++\n")
		code.WriteString("\t}\n\n")
	} else {
		// Backward growth (end-start)
		code.WriteString(fmt.Sprintf("\toffset = %d\n", start))

		// Count validation if count field exists
		if countField != "" {
			code.WriteString(fmt.Sprintf("\tif len(p.%s) != int(p.%s) {\n", field.Name, countField))
			code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"%s length mismatch: have %%d, want %%d\", len(p.%s), p.%s)\n",
				field.Name, field.Name, countField))
			code.WriteString("\t}\n")
		}

		// Marshal backward
		code.WriteString(fmt.Sprintf("\tfor i := len(p.%s) - 1; i >= 0; i-- {\n", field.Name))
		code.WriteString("\t\toffset--\n")
		code.WriteString(fmt.Sprintf("\t\tif offset < %d {\n", boundary))
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"%s collision at offset %%d\", offset)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tbuf[offset] = p.%s[i]\n", field.Name))
		code.WriteString("\t}\n\n")
	}

	return code.String()
}

// generateStructMarshal generates element-by-element marshal for []StructType
func (g *Generator) generateStructMarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField
	elementSize := region.ElementSize

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s (element size: %d)\n",
			field.Name, field.GoType, start, boundary, countField, elementSize))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) (element size: %d)\n",
			field.Name, field.GoType, start, boundary, elementSize))
	}

	if region.Direction == parser.StartEnd {
		// Forward growth
		code.WriteString(fmt.Sprintf("\toffset = %d\n", start))

		// Count validation if count field exists
		if countField != "" {
			code.WriteString(fmt.Sprintf("\tif len(p.%s) != int(p.%s) {\n", field.Name, countField))
			code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"%s length mismatch: have %%d, want %%d\", len(p.%s), p.%s)\n",
				field.Name, field.Name, countField))
			code.WriteString("\t}\n")
		}

		// Marshal loop for structs
		code.WriteString(fmt.Sprintf("\tfor i := range p.%s {\n", field.Name))
		code.WriteString(fmt.Sprintf("\t\tif offset + %d > %d {\n", elementSize, boundary))
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"%s collision at offset %%d\", offset)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\telemBuf, err := p.%s[i].MarshalLayout()\n", field.Name))
		code.WriteString("\t\tif err != nil {\n")
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"marshal %s[%%d]: %%w\", i, err)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tcopy(buf[offset:offset+%d], elemBuf)\n", elementSize))
		code.WriteString(fmt.Sprintf("\t\toffset += %d\n", elementSize))
		code.WriteString("\t}\n\n")
	} else {
		// Backward growth (end-start)
		code.WriteString(fmt.Sprintf("\toffset = %d\n", start))

		// Count validation if count field exists
		if countField != "" {
			code.WriteString(fmt.Sprintf("\tif len(p.%s) != int(p.%s) {\n", field.Name, countField))
			code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"%s length mismatch: have %%d, want %%d\", len(p.%s), p.%s)\n",
				field.Name, field.Name, countField))
			code.WriteString("\t}\n")
		}

		// Marshal backward for structs
		code.WriteString(fmt.Sprintf("\tfor i := len(p.%s) - 1; i >= 0; i-- {\n", field.Name))
		code.WriteString(fmt.Sprintf("\t\toffset -= %d\n", elementSize))
		code.WriteString(fmt.Sprintf("\t\tif offset < %d {\n", boundary))
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"%s collision at offset %%d\", offset)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\telemBuf, err := p.%s[i].MarshalLayout()\n", field.Name))
		code.WriteString("\t\tif err != nil {\n")
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"marshal %s[%%d]: %%w\", i, err)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tcopy(buf[offset:offset+%d], elemBuf)\n", elementSize))
		code.WriteString("\t}\n\n")
	}

	return code.String()
}

// generateDynamicUnmarshal generates unmarshal code for a dynamic field
func (g *Generator) generateDynamicUnmarshal(region analyzer.Region) string {
	// Check element type to determine unmarshal strategy
	if region.ElementType == "byte" {
		return g.generateByteUnmarshal(region)
	}
	return g.generateStructUnmarshal(region)
}

// generateByteUnmarshal generates byte-by-byte unmarshal for []byte
func (g *Generator) generateByteUnmarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s\n",
			field.Name, field.GoType, start, boundary, countField))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n",
			field.Name, field.GoType, start, boundary))
	}

	// Calculate length
	if countField != "" {
		// Explicit count
		code.WriteString(fmt.Sprintf("\t// Reuse buffer if capacity allows\n"))
		code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= int(p.%s) {\n", field.Name, countField))
		code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:p.%s]\n", field.Name, field.Name, countField))
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tp.%s = make([]byte, p.%s)\n", field.Name, countField))
		code.WriteString("\t}\n")

		if region.Direction == parser.StartEnd {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d:%d+p.%s])\n\n", field.Name, start, start, countField))
		} else {
			// Backward: copy from (start - count) to start
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d-p.%s:%d])\n\n", field.Name, start, countField, start))
		}
	} else {
		// Implicit length from boundaries
		lenVar := fmt.Sprintf("%sLen", strings.ToLower(string(field.Name[0])))
		if region.Direction == parser.StartEnd {
			code.WriteString(fmt.Sprintf("\t%s := %d - %d\n", lenVar, boundary, start))
		} else {
			code.WriteString(fmt.Sprintf("\t%s := %d - %d\n", lenVar, start, boundary))
		}

		code.WriteString(fmt.Sprintf("\t// Reuse buffer if capacity allows\n"))
		code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= %s {\n", field.Name, lenVar))
		code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:%s]\n", field.Name, field.Name, lenVar))
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tp.%s = make([]byte, %s)\n", field.Name, lenVar))
		code.WriteString("\t}\n")

		if region.Direction == parser.StartEnd {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d:%d])\n\n", field.Name, start, boundary))
		} else {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d:%d])\n\n", field.Name, boundary, start))
		}
	}

	return code.String()
}

// generateStructUnmarshal generates element-by-element unmarshal for []StructType
func (g *Generator) generateStructUnmarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField
	elementSize := region.ElementSize
	elementType := region.ElementType

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s (element size: %d)\n",
			field.Name, field.GoType, start, boundary, countField, elementSize))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) (element size: %d)\n",
			field.Name, field.GoType, start, boundary, elementSize))
	}

	// Calculate number of elements
	if countField != "" {
		// Explicit count
		code.WriteString(fmt.Sprintf("\t// Reuse slice if capacity allows\n"))
		code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= int(p.%s) {\n", field.Name, countField))
		code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:p.%s]\n", field.Name, field.Name, countField))
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tp.%s = make([]%s, p.%s)\n", field.Name, elementType, countField))
		code.WriteString("\t}\n")
	} else {
		// Implicit count from region size
		numElements := (boundary - start) / elementSize
		if region.Direction == parser.EndStart {
			numElements = (start - boundary) / elementSize
		}
		code.WriteString(fmt.Sprintf("\tnumElements := %d // (%d bytes / %d bytes per element)\n",
			numElements, abs(boundary-start), elementSize))
		code.WriteString(fmt.Sprintf("\t// Reuse slice if capacity allows\n"))
		code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= numElements {\n", field.Name))
		code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:numElements]\n", field.Name, field.Name))
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tp.%s = make([]%s, numElements)\n", field.Name, elementType))
		code.WriteString("\t}\n")
	}

	// Unmarshal loop
	code.WriteString(fmt.Sprintf("\toffset := %d\n", start))
	code.WriteString(fmt.Sprintf("\tfor i := range p.%s {\n", field.Name))

	if region.Direction == parser.StartEnd {
		code.WriteString(fmt.Sprintf("\t\tif err := p.%s[i].UnmarshalLayout(buf[offset:offset+%d]); err != nil {\n",
			field.Name, elementSize))
		code.WriteString(fmt.Sprintf("\t\t\treturn fmt.Errorf(\"unmarshal %s[%%d]: %%w\", i, err)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\toffset += %d\n", elementSize))
	} else {
		// Backward
		code.WriteString(fmt.Sprintf("\t\tif err := p.%s[i].UnmarshalLayout(buf[offset-%d:offset]); err != nil {\n",
			field.Name, elementSize))
		code.WriteString(fmt.Sprintf("\t\t\treturn fmt.Errorf(\"unmarshal %s[%%d]: %%w\", i, err)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\toffset -= %d\n", elementSize))
	}

	code.WriteString("\t}\n\n")

	return code.String()
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

// generateZeroCopyDynamicUnmarshal generates zero-copy unmarshal for dynamic field
func (g *Generator) generateZeroCopyDynamicUnmarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField

	// Handle []byte - slice directly from p.buf
	if field.GoType == "[]byte" {
		// Comment
		if countField != "" {
			code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s\n",
				field.Name, field.GoType, start, boundary, countField))
		} else {
			code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n",
				field.Name, field.GoType, start, boundary))
		}

		// Check if this region is referenced by indirect slices
		isIndirectRegion := false
		if g.layout != nil {
			for _, f := range g.layout.Fields {
				if f.Layout.From != "" && f.Layout.Region == field.Name {
					isIndirectRegion = true
					break
				}
			}
		}

		// For end-start regions used as data regions for indirect slices,
		// skip automatic initialization - it will be set by RebuildIndirectSlices
		if region.Direction == parser.EndStart && isIndirectRegion {
			code.WriteString(fmt.Sprintf("\t// %s: end-start data region, set by indirect slice reconstruction\n\n", field.Name))
			return code.String()
		}

		// Slice directly into buffer
		if countField != "" {
			// Count-dependent slicing
			if region.Direction == parser.StartEnd {
				// Forward: slice from start with count
				code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d:%d+p.%s]\n\n", field.Name, start, start, countField))
			} else {
				// Backward: slice from (start - count) to start
				code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d-p.%s:%d]\n\n", field.Name, start, countField, start))
			}
		} else {
			// Implicit length from boundaries
			if region.Direction == parser.StartEnd {
				code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d:%d]\n\n", field.Name, start, boundary))
			} else {
				code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d:%d]\n\n", field.Name, boundary, start))
			}
		}
		return code.String()
	}

	// Handle struct slices - need to unmarshal each element
	elementSize := region.ElementSize
	elementType := region.ElementType

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s (element size: %d)\n",
			field.Name, field.GoType, start, boundary, countField, elementSize))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) (element size: %d)\n",
			field.Name, field.GoType, start, boundary, elementSize))
	}

	// Calculate number of elements
	if countField != "" {
		// Explicit count
		code.WriteString(fmt.Sprintf("\t// Reuse slice if capacity allows\n"))
		code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= int(p.%s) {\n", field.Name, countField))
		code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:p.%s]\n", field.Name, field.Name, countField))
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tp.%s = make([]%s, p.%s)\n", field.Name, elementType, countField))
		code.WriteString("\t}\n")
	} else {
		// Implicit count from region size
		numElements := (boundary - start) / elementSize
		if region.Direction == parser.EndStart {
			numElements = (start - boundary) / elementSize
		}
		code.WriteString(fmt.Sprintf("\tnumElements := %d // (%d bytes / %d bytes per element)\n",
			numElements, abs(boundary-start), elementSize))
		code.WriteString(fmt.Sprintf("\t// Reuse slice if capacity allows\n"))
		code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= numElements {\n", field.Name))
		code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:numElements]\n", field.Name, field.Name))
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tp.%s = make([]%s, numElements)\n", field.Name, elementType))
		code.WriteString("\t}\n")
	}

	// Unmarshal loop
	code.WriteString(fmt.Sprintf("\toffset := %d\n", start))
	code.WriteString(fmt.Sprintf("\tfor i := range p.%s {\n", field.Name))

	if region.Direction == parser.StartEnd {
		code.WriteString(fmt.Sprintf("\t\tif err := p.%s[i].UnmarshalLayout(p.buf[offset:offset+%d]); err != nil {\n",
			field.Name, elementSize))
		code.WriteString(fmt.Sprintf("\t\t\treturn fmt.Errorf(\"unmarshal %s[%%d]: %%w\", i, err)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\toffset += %d\n", elementSize))
	} else {
		// Backward
		code.WriteString(fmt.Sprintf("\t\tif err := p.%s[i].UnmarshalLayout(p.buf[offset-%d:offset]); err != nil {\n",
			field.Name, elementSize))
		code.WriteString(fmt.Sprintf("\t\t\treturn fmt.Errorf(\"unmarshal %s[%%d]: %%w\", i, err)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\toffset -= %d\n", elementSize))
	}

	code.WriteString("\t}\n\n")

	return code.String()
}

// generateZeroCopyDynamicMarshal generates marshal code for dynamic field into p.buf
func (g *Generator) generateZeroCopyDynamicMarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField

	// Handle []byte - already in p.buf, no copy needed
	if field.GoType == "[]byte" {
		// Comment
		if countField != "" {
			code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s\n",
				field.Name, field.GoType, start, boundary, countField))
		} else {
			code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n",
				field.Name, field.GoType, start, boundary))
		}
		code.WriteString(fmt.Sprintf("\t// %s is already sliced from p.buf, no copy needed\n\n", field.Name))
		return code.String()
	}

	// Handle struct slices - need to marshal each element
	elementSize := region.ElementSize

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s (element size: %d)\n",
			field.Name, field.GoType, start, boundary, countField, elementSize))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) (element size: %d)\n",
			field.Name, field.GoType, start, boundary, elementSize))
	}

	// Count validation if count field exists
	if countField != "" {
		code.WriteString(fmt.Sprintf("\tif len(p.%s) != int(p.%s) {\n", field.Name, countField))
		code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"%s length mismatch: have %%d, want %%d\", len(p.%s), p.%s)\n",
			field.Name, field.Name, countField))
		code.WriteString("\t}\n")
	}

	// Marshal loop for structs
	if region.Direction == parser.StartEnd {
		// Forward growth
		code.WriteString(fmt.Sprintf("\toffset := %d\n", start))
		code.WriteString(fmt.Sprintf("\tfor i := range p.%s {\n", field.Name))
		code.WriteString(fmt.Sprintf("\t\tif offset + %d > %d {\n", elementSize, boundary))
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"%s collision at offset %%d\", offset)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\telemBuf, err := p.%s[i].MarshalLayout()\n", field.Name))
		code.WriteString("\t\tif err != nil {\n")
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"marshal %s[%%d]: %%w\", i, err)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tcopy(p.buf[offset:offset+%d], elemBuf)\n", elementSize))
		code.WriteString(fmt.Sprintf("\t\toffset += %d\n", elementSize))
		code.WriteString("\t}\n\n")
	} else {
		// Backward growth
		code.WriteString(fmt.Sprintf("\toffset := %d\n", start))
		code.WriteString(fmt.Sprintf("\tfor i := len(p.%s) - 1; i >= 0; i-- {\n", field.Name))
		code.WriteString(fmt.Sprintf("\t\toffset -= %d\n", elementSize))
		code.WriteString(fmt.Sprintf("\t\tif offset < %d {\n", boundary))
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"%s collision at offset %%d\", offset)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\telemBuf, err := p.%s[i].MarshalLayout()\n", field.Name))
		code.WriteString("\t\tif err != nil {\n")
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"marshal %s[%%d]: %%w\", i, err)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tcopy(p.buf[offset:offset+%d], elemBuf)\n", elementSize))
		code.WriteString("\t}\n\n")
	}

	return code.String()
}

// generateIndirectUnmarshal generates unmarshal code for [][]byte with metadata indirection
func (g *Generator) generateIndirectUnmarshal(field parser.Field) string {
	var code strings.Builder

	// Comment
	code.WriteString(fmt.Sprintf("\t// %s: [][]byte from=%s offset=%s size=%s region=%s\n",
		field.Name, field.Layout.From, field.Layout.OffsetField, field.Layout.SizeField, field.Layout.Region))

	// For end-start data regions, we need to calculate where Data should start
	// This only needs to be done once for all indirect slices
	// Check if this is the first indirect field and if Data region needs initialization
	if g.layout != nil {
		isFirstIndirect := true
		for _, f := range g.layout.Fields {
			if f.Layout.From != "" {
				if f.Name == field.Name {
					break
				} else {
					isFirstIndirect = false
					break
				}
			}
		}

		// If this is the first indirect slice, initialize the Data region
		if isFirstIndirect {
			// Find the metadata region to calculate elementsEnd
			for _, region := range g.analyzed.Regions {
				if region.Kind == analyzer.DynamicRegion &&
				   region.Direction == parser.StartEnd &&
				   region.ElementType != "byte" &&
				   region.Field.Name == field.Layout.From {
					countFieldName := strings.Split(region.Field.Layout.CountField, ".")[len(strings.Split(region.Field.Layout.CountField, "."))-1]
					code.WriteString(fmt.Sprintf("\t// Initialize %s data region after metadata\n", field.Layout.Region))
					code.WriteString(fmt.Sprintf("\telementsEnd := %d + int(p.%s)*%d\n",
						region.Start, countFieldName, region.ElementSize))
					code.WriteString(fmt.Sprintf("\tp.%s = p.buf[elementsEnd:%d]\n\n", field.Layout.Region, g.analyzed.BufferSize))
					break
				}
			}
		}
	}

	// Allocate slice matching source length
	code.WriteString(fmt.Sprintf("\t// Reuse slice if capacity allows\n"))
	code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= len(p.%s) {\n", field.Name, field.Layout.From))
	code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:len(p.%s)]\n", field.Name, field.Name, field.Layout.From))
	code.WriteString("\t} else {\n")
	code.WriteString(fmt.Sprintf("\t\tp.%s = make([][]byte, len(p.%s))\n", field.Name, field.Layout.From))
	code.WriteString("\t}\n")

	// Loop through source elements and create slices
	code.WriteString(fmt.Sprintf("\tfor i := range p.%s {\n", field.Layout.From))
	code.WriteString(fmt.Sprintf("\t\toffset := int(p.%s[i].%s)\n", field.Layout.From, field.Layout.OffsetField))
	code.WriteString(fmt.Sprintf("\t\tsize := int(p.%s[i].%s)\n", field.Layout.From, field.Layout.SizeField))
	code.WriteString(fmt.Sprintf("\t\tp.%s[i] = p.%s[offset:offset+size]\n", field.Name, field.Layout.Region))
	code.WriteString("\t}\n\n")

	return code.String()
}

// getMetadataFieldType looks up the type of a field in the metadata struct
func (g *Generator) getMetadataFieldType(fromField, fieldName string) string {
	// Find the source field in current layout
	var sourceField *parser.Field
	for i := range g.layout.Fields {
		if g.layout.Fields[i].Name == fromField {
			sourceField = &g.layout.Fields[i]
			break
		}
	}
	if sourceField == nil {
		return "uint32" // fallback
	}

	// Extract element type from slice: []LeafElement â†’ LeafElement
	elemType := strings.TrimPrefix(sourceField.GoType, "[]")

	// Find the element type's layout in all parsed layouts
	for _, layout := range g.allLayouts {
		if layout.Name == elemType {
			// Find the field in this layout
			for _, f := range layout.Fields {
				if f.Name == fieldName {
					return f.GoType
				}
			}
		}
	}

	return "uint32" // fallback if not found
}

// generateIndirectMarshal generates marshal code for [][]byte with backward packing
func (g *Generator) generateIndirectMarshal(field parser.Field) string {
	var code strings.Builder

	// Comment
	code.WriteString(fmt.Sprintf("\t// %s: [][]byte packed backward into %s, updating %s metadata\n",
		field.Name, field.Layout.Region, field.Layout.From))

	// Find the region field to determine pack start point
	var regionField *parser.Field
	for i := range g.layout.Fields {
		if g.layout.Fields[i].Name == field.Layout.Region {
			regionField = &g.layout.Fields[i]
			break
		}
	}

	// Pack backward from region end
	var packStart string
	if regionField != nil && regionField.Layout.Direction == parser.EndStart {
		// Region is end-start, so it starts at bufferSize and grows backward
		packStart = fmt.Sprintf("%d", g.analyzed.BufferSize)
	} else {
		// Default: pack from buffer end
		packStart = fmt.Sprintf("%d", g.analyzed.BufferSize)
	}

	// Look up actual field types for offset and size
	offsetType := g.getMetadataFieldType(field.Layout.From, field.Layout.OffsetField)
	sizeType := g.getMetadataFieldType(field.Layout.From, field.Layout.SizeField)

	code.WriteString(fmt.Sprintf("\toffset = %s\n", packStart))
	code.WriteString(fmt.Sprintf("\tfor i := len(p.%s) - 1; i >= 0; i-- {\n", field.Name))
	code.WriteString(fmt.Sprintf("\t\tsize := len(p.%s[i])\n", field.Name))
	code.WriteString("\t\toffset -= size\n")
	code.WriteString(fmt.Sprintf("\t\tcopy(buf[offset:offset+size], p.%s[i])\n", field.Name))
	code.WriteString(fmt.Sprintf("\t\tp.%s[i].%s = %s(offset)\n", field.Layout.From, field.Layout.OffsetField, offsetType))
	code.WriteString(fmt.Sprintf("\t\tp.%s[i].%s = %s(size)\n", field.Layout.From, field.Layout.SizeField, sizeType))
	code.WriteString("\t}\n\n")

	return code.String()
}

// generateRebuildIndirectSlices generates a helper function to rebuild Elements and Data from indirect slices
func (g *Generator) generateRebuildIndirectSlices() string {
	var code strings.Builder

	code.WriteString(fmt.Sprintf("\n// RebuildIndirectSlices rebuilds the physical layout from logical slices\n"))
	code.WriteString(fmt.Sprintf("// Call this after modifying Keys/Values before calling MarshalLayout\n"))
	code.WriteString(fmt.Sprintf("func (p *%s) RebuildIndirectSlices() {\n", g.analyzed.TypeName))

	// Find the metadata slice (Elements) and data region (Data)
	var metadataRegion *analyzer.Region
	var dataRegion *analyzer.Region
	
	for i := range g.analyzed.Regions {
		region := &g.analyzed.Regions[i]
		if region.Kind == analyzer.DynamicRegion {
			if region.Direction == parser.StartEnd && region.ElementType != "byte" {
				metadataRegion = region
			} else if region.Direction == parser.EndStart && region.Field.GoType == "[]byte" {
				dataRegion = region
			}
		}
	}

	if metadataRegion == nil || dataRegion == nil {
		// Can't rebuild without both metadata and data regions
		code.WriteString("\t// No metadata/data regions to rebuild\n")
		code.WriteString("}\n")
		return code.String()
	}

	// Calculate where metadata ends
	code.WriteString(fmt.Sprintf("\t// Calculate where %s ends\n", metadataRegion.Field.Name))
	code.WriteString(fmt.Sprintf("\telementsEnd := %d + int(p.%s)*%d\n",
		metadataRegion.Start,
		strings.Split(metadataRegion.Field.Layout.CountField, ".")[len(strings.Split(metadataRegion.Field.Layout.CountField, "."))-1],
		metadataRegion.ElementSize))

	// Initialize Data buffer after Elements
	code.WriteString(fmt.Sprintf("\t\n\t// Initialize %s buffer after %s\n", dataRegion.Field.Name, metadataRegion.Field.Name))
	code.WriteString(fmt.Sprintf("\tp.%s = p.buf[elementsEnd:elementsEnd:%d]\n", dataRegion.Field.Name, g.analyzed.BufferSize))

	// Rebuild metadata slice if needed
	code.WriteString(fmt.Sprintf("\t\n\t// Rebuild %s array\n", metadataRegion.Field.Name))
	code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= int(p.%s) {\n",
		metadataRegion.Field.Name,
		strings.Split(metadataRegion.Field.Layout.CountField, ".")[len(strings.Split(metadataRegion.Field.Layout.CountField, "."))-1]))
	code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:p.%s]\n",
		metadataRegion.Field.Name,
		metadataRegion.Field.Name,
		strings.Split(metadataRegion.Field.Layout.CountField, ".")[len(strings.Split(metadataRegion.Field.Layout.CountField, "."))-1]))
	code.WriteString("\t} else {\n")
	code.WriteString(fmt.Sprintf("\t\tp.%s = make([]%s, p.%s)\n",
		metadataRegion.Field.Name,
		metadataRegion.ElementType,
		strings.Split(metadataRegion.Field.Layout.CountField, ".")[len(strings.Split(metadataRegion.Field.Layout.CountField, "."))-1]))
	code.WriteString("\t}\n")

	// Pack all indirect slices into Data backward from the end
	code.WriteString("\t\n\t// Pack indirect slices into Data region backward from end\n")
	code.WriteString(fmt.Sprintf("\toffset := %d\n", g.analyzed.BufferSize))

	// Collect all indirect slice fields
	var indirectFields []parser.Field
	if g.layout != nil {
		for _, field := range g.layout.Fields {
			if field.Layout.From != "" {
				indirectFields = append(indirectFields, field)
			}
		}
	}

	// Generate packing code: pack all fields for each element together
	if len(indirectFields) > 0 {
		// Determine count field from first indirect field
		firstFrom := indirectFields[0].Layout.From

		code.WriteString(fmt.Sprintf("\t\n\t// Pack all indirect slices backward from end (elements in forward order)\n"))
		code.WriteString(fmt.Sprintf("\tfor i := 0; i < len(p.%s); i++ {\n", indirectFields[0].Name))

		// Pack each field for this element in forward order (Key before Value)
		for j := 0; j < len(indirectFields); j++ {
			field := indirectFields[j]
			offsetType := g.getMetadataFieldType(field.Layout.From, field.Layout.OffsetField)
			sizeType := g.getMetadataFieldType(field.Layout.From, field.Layout.SizeField)
			sizeVar := fmt.Sprintf("size%d", j)

			code.WriteString(fmt.Sprintf("\t\t// Pack %s[i]\n", field.Name))
			code.WriteString(fmt.Sprintf("\t\t%s := len(p.%s[i])\n", sizeVar, field.Name))
			code.WriteString(fmt.Sprintf("\t\toffset -= %s\n", sizeVar))
			code.WriteString(fmt.Sprintf("\t\tcopy(p.buf[offset:offset+%s], p.%s[i])\n", sizeVar, field.Name))
			code.WriteString(fmt.Sprintf("\t\tp.%s[i].%s = %s(offset - elementsEnd)\n",
				firstFrom, field.Layout.OffsetField, offsetType))
			code.WriteString(fmt.Sprintf("\t\tp.%s[i].%s = %s(%s)\n",
				firstFrom, field.Layout.SizeField, sizeType, sizeVar))
		}

		code.WriteString("\t}\n")
	}

	code.WriteString("}\n")

	return code.String()
}
