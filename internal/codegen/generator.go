package codegen

import (
	"fmt"
	"strings"

	"github.com/alexhholmes/layout/internal/analyzer"
	"github.com/alexhholmes/layout/internal/parser"
)

// Generator generates marshal/unmarshal code for binary layouts
type Generator struct {
	analyzed *analyzer.AnalyzedLayout
	registry *analyzer.TypeRegistry
	endian   string // "little" or "big"
}

// NewGenerator creates a new code generator
func NewGenerator(analyzed *analyzer.AnalyzedLayout, reg *analyzer.TypeRegistry, endian string) *Generator {
	if endian == "" {
		endian = "little"
	}
	return &Generator{
		analyzed: analyzed,
		registry: reg,
		endian:   endian,
	}
}

// Generate returns the complete generated file content
func (g *Generator) Generate() (string, error) {
	var out strings.Builder

	// Package comment
	out.WriteString("// Code generated by layout. DO NOT EDIT.\n\n")
	out.WriteString("package main\n\n")

	// Imports
	out.WriteString("import (\n")
	out.WriteString("\t\"encoding/binary\"\n")
	out.WriteString("\t\"fmt\"\n")
	out.WriteString(")\n\n")

	// Generate marshal method
	marshal := g.GenerateMarshal()
	out.WriteString(marshal)
	out.WriteString("\n")

	// Generate unmarshal method
	unmarshal := g.GenerateUnmarshal()
	out.WriteString(unmarshal)

	return out.String(), nil
}

// GenerateMarshal generates the MarshalLayout method
func (g *Generator) GenerateMarshal() string {
	var code strings.Builder

	// Function signature
	code.WriteString(fmt.Sprintf("func (p *%s) MarshalLayout() ([]byte, error) {\n", g.analyzed.TypeName))
	code.WriteString(fmt.Sprintf("\tbuf := make([]byte, %d)\n\n", g.analyzed.BufferSize))

	// Generate code for each region
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.FixedRegion {
			code.WriteString(g.generateFixedMarshal(region))
		} else {
			code.WriteString(g.generateDynamicMarshal(region))
		}
	}

	code.WriteString("\treturn buf, nil\n")
	code.WriteString("}\n")

	return code.String()
}

// GenerateUnmarshal generates the UnmarshalLayout method
func (g *Generator) GenerateUnmarshal() string {
	var code strings.Builder

	// Function signature
	code.WriteString(fmt.Sprintf("func (p *%s) UnmarshalLayout(buf []byte) error {\n", g.analyzed.TypeName))

	// Buffer size check
	code.WriteString(fmt.Sprintf("\tif len(buf) != %d {\n", g.analyzed.BufferSize))
	code.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"expected %d bytes, got %%d\", len(buf))\n", g.analyzed.BufferSize))
	code.WriteString("\t}\n\n")

	// Generate code for each region
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.FixedRegion {
			code.WriteString(g.generateFixedUnmarshal(region))
		} else {
			code.WriteString(g.generateDynamicUnmarshal(region))
		}
	}

	code.WriteString("\treturn nil\n")
	code.WriteString("}\n")

	return code.String()
}

// generateFixedMarshal generates marshal code for a fixed-size field
func (g *Generator) generateFixedMarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	end := region.Boundary

	// Comment
	code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n", field.Name, field.GoType, start, end))

	// Generate appropriate binary operation based on type
	switch field.GoType {
	case "uint8", "int8", "byte":
		code.WriteString(fmt.Sprintf("\tbuf[%d] = p.%s\n\n", start, field.Name))

	case "uint16", "int16":
		putFunc := g.binaryPutFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\t%s.%s(buf[%d:%d], p.%s)\n\n",
			g.endianPrefix(), putFunc, start, end, field.Name))

	case "uint32", "int32":
		putFunc := g.binaryPutFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\t%s.%s(buf[%d:%d], p.%s)\n\n",
			g.endianPrefix(), putFunc, start, end, field.Name))

	case "uint64", "int64":
		putFunc := g.binaryPutFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\t%s.%s(buf[%d:%d], p.%s)\n\n",
			g.endianPrefix(), putFunc, start, end, field.Name))

	default:
		// Handle arrays
		if strings.HasPrefix(field.GoType, "[") && strings.Contains(field.GoType, "]byte") {
			code.WriteString(fmt.Sprintf("\tcopy(buf[%d:%d], p.%s[:])\n\n", start, end, field.Name))
		} else {
			code.WriteString(fmt.Sprintf("\t// TODO: marshal %s\n\n", field.GoType))
		}
	}

	return code.String()
}

// generateFixedUnmarshal generates unmarshal code for a fixed-size field
func (g *Generator) generateFixedUnmarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	end := region.Boundary

	// Comment
	code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n", field.Name, field.GoType, start, end))

	// Generate appropriate binary operation based on type
	switch field.GoType {
	case "uint8", "int8", "byte":
		code.WriteString(fmt.Sprintf("\tp.%s = buf[%d]\n\n", field.Name, start))

	case "uint16", "int16":
		getFunc := g.binaryGetFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\tp.%s = %s.%s(buf[%d:%d])\n\n",
			field.Name, g.endianPrefix(), getFunc, start, end))

	case "uint32", "int32":
		getFunc := g.binaryGetFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\tp.%s = %s.%s(buf[%d:%d])\n\n",
			field.Name, g.endianPrefix(), getFunc, start, end))

	case "uint64", "int64":
		getFunc := g.binaryGetFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\tp.%s = %s.%s(buf[%d:%d])\n\n",
			field.Name, g.endianPrefix(), getFunc, start, end))

	default:
		// Handle arrays
		if strings.HasPrefix(field.GoType, "[") && strings.Contains(field.GoType, "]byte") {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s[:], buf[%d:%d])\n\n", field.Name, start, end))
		} else {
			code.WriteString(fmt.Sprintf("\t// TODO: unmarshal %s\n\n", field.GoType))
		}
	}

	return code.String()
}

// binaryPutFunc returns the binary.PutXXX function name for a type
func (g *Generator) binaryPutFunc(goType string) string {
	switch goType {
	case "uint16":
		return "PutUint16"
	case "uint32":
		return "PutUint32"
	case "uint64":
		return "PutUint64"
	case "int16":
		return "PutUint16"
	case "int32":
		return "PutUint32"
	case "int64":
		return "PutUint64"
	default:
		return "PutUint32" // fallback
	}
}

// binaryGetFunc returns the binary.Uint32() function name for a type
func (g *Generator) binaryGetFunc(goType string) string {
	switch goType {
	case "uint16":
		return "Uint16"
	case "uint32":
		return "Uint32"
	case "uint64":
		return "Uint64"
	case "int16":
		return "Uint16"
	case "int32":
		return "Uint32"
	case "int64":
		return "Uint64"
	default:
		return "Uint32" // fallback
	}
}

// endianPrefix returns "binary.LittleEndian" or "binary.BigEndian"
func (g *Generator) endianPrefix() string {
	if g.endian == "big" {
		return "binary.BigEndian"
	}
	return "binary.LittleEndian"
}

// generateDynamicMarshal generates marshal code for a dynamic field
func (g *Generator) generateDynamicMarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField

	// Only handle []byte for now
	if field.GoType != "[]byte" {
		code.WriteString(fmt.Sprintf("\t// TODO: marshal dynamic %s\n\n", field.GoType))
		return code.String()
	}

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s\n",
			field.Name, field.GoType, start, boundary, countField))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n",
			field.Name, field.GoType, start, boundary))
	}

	if region.Direction == parser.StartEnd {
		// Forward growth
		code.WriteString(fmt.Sprintf("\toffset := %d\n", start))

		// Count validation if count field exists
		if countField != "" {
			code.WriteString(fmt.Sprintf("\tif len(p.%s) != int(p.%s) {\n", field.Name, countField))
			code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"%s length mismatch: have %%d, want %%d\", len(p.%s), p.%s)\n",
				field.Name, field.Name, countField))
			code.WriteString("\t}\n")
		}

		// Marshal loop
		code.WriteString(fmt.Sprintf("\tfor i := range p.%s {\n", field.Name))
		code.WriteString(fmt.Sprintf("\t\tif offset >= %d {\n", boundary))
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"%s collision at offset %%d\", offset)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tbuf[offset] = p.%s[i]\n", field.Name))
		code.WriteString("\t\toffset++\n")
		code.WriteString("\t}\n\n")
	} else {
		// Backward growth (end-start)
		code.WriteString(fmt.Sprintf("\toffset := %d\n", start))

		// Count validation if count field exists
		if countField != "" {
			code.WriteString(fmt.Sprintf("\tif len(p.%s) != int(p.%s) {\n", field.Name, countField))
			code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"%s length mismatch: have %%d, want %%d\", len(p.%s), p.%s)\n",
				field.Name, field.Name, countField))
			code.WriteString("\t}\n")
		}

		// Marshal backward
		code.WriteString(fmt.Sprintf("\tfor i := len(p.%s) - 1; i >= 0; i-- {\n", field.Name))
		code.WriteString("\t\toffset--\n")
		code.WriteString(fmt.Sprintf("\t\tif offset < %d {\n", boundary))
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"%s collision at offset %%d\", offset)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tbuf[offset] = p.%s[i]\n", field.Name))
		code.WriteString("\t}\n\n")
	}

	return code.String()
}

// generateDynamicUnmarshal generates unmarshal code for a dynamic field
func (g *Generator) generateDynamicUnmarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField

	// Only handle []byte for now
	if field.GoType != "[]byte" {
		code.WriteString(fmt.Sprintf("\t// TODO: unmarshal dynamic %s\n\n", field.GoType))
		return code.String()
	}

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s\n",
			field.Name, field.GoType, start, boundary, countField))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n",
			field.Name, field.GoType, start, boundary))
	}

	// Calculate length
	if countField != "" {
		// Explicit count
		code.WriteString(fmt.Sprintf("\t// Reuse buffer if capacity allows\n"))
		code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= int(p.%s) {\n", field.Name, countField))
		code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:p.%s]\n", field.Name, field.Name, countField))
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tp.%s = make([]byte, p.%s)\n", field.Name, countField))
		code.WriteString("\t}\n")

		if region.Direction == parser.StartEnd {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d:%d+p.%s])\n\n", field.Name, start, start, countField))
		} else {
			// Backward: copy from (start - count) to start
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d-p.%s:%d])\n\n", field.Name, start, countField, start))
		}
	} else {
		// Implicit length from boundaries
		lenVar := fmt.Sprintf("%sLen", strings.ToLower(string(field.Name[0])))
		if region.Direction == parser.StartEnd {
			code.WriteString(fmt.Sprintf("\t%s := %d - %d\n", lenVar, boundary, start))
		} else {
			code.WriteString(fmt.Sprintf("\t%s := %d - %d\n", lenVar, start, boundary))
		}

		code.WriteString(fmt.Sprintf("\t// Reuse buffer if capacity allows\n"))
		code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= %s {\n", field.Name, lenVar))
		code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:%s]\n", field.Name, field.Name, lenVar))
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tp.%s = make([]byte, %s)\n", field.Name, lenVar))
		code.WriteString("\t}\n")

		if region.Direction == parser.StartEnd {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d:%d])\n\n", field.Name, start, boundary))
		} else {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d:%d])\n\n", field.Name, boundary, start))
		}
	}

	return code.String()
}
