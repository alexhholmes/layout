package codegen

import (
	"fmt"
	"strings"

	"github.com/alexhholmes/layout/internal/analyzer"
	"github.com/alexhholmes/layout/internal/parser"
)

// Generator generates marshal/unmarshal code for binary layouts
type Generator struct {
	analyzed  *analyzer.AnalyzedLayout
	layout    *parser.TypeLayout // Original parsed layout (for indirect slices)
	registry  *analyzer.TypeRegistry
	endian    string // "little" or "big"
	mode      string // "copy" or "zerocopy"
	align     int    // alignment requirement (0 = none)
	allocator string // custom allocator function name (optional)
}

// NewGenerator creates a new code generator
func NewGenerator(analyzed *analyzer.AnalyzedLayout, layout *parser.TypeLayout, reg *analyzer.TypeRegistry, endian string, mode string, align int, allocator string) *Generator {
	if endian == "" {
		endian = "little"
	}
	if mode == "" {
		mode = "copy"
	}
	return &Generator{
		analyzed:  analyzed,
		layout:    layout,
		registry:  reg,
		endian:    endian,
		mode:      mode,
		align:     align,
		allocator: allocator,
	}
}

// Generate returns the complete generated file content
func (g *Generator) Generate() (string, error) {
	var out strings.Builder

	// Package comment
	out.WriteString("// Code generated by layout. DO NOT EDIT.\n\n")
	out.WriteString("package main\n\n")

	// Imports
	out.WriteString("import (\n")
	if g.mode != "zerocopy" {
		out.WriteString("\t\"encoding/binary\"\n")
		out.WriteString("\t\"fmt\"\n")
	}
	if g.mode == "zerocopy" {
		out.WriteString("\t\"fmt\"\n")
		out.WriteString("\t\"io\"\n")
		out.WriteString("\t\"unsafe\"\n")
	}
	out.WriteString(")\n\n")

	// Generate marshal method
	marshal := g.GenerateMarshal()
	out.WriteString(marshal)
	out.WriteString("\n")

	// Generate unmarshal method
	unmarshal := g.GenerateUnmarshal()
	out.WriteString(unmarshal)

	return out.String(), nil
}

// GenerateMarshal generates the MarshalLayout method
func (g *Generator) GenerateMarshal() string {
	if g.mode == "zerocopy" {
		return g.generateZeroCopyMarshal()
	}
	return g.generateCopyMarshal()
}

// generateCopyMarshal generates copy-mode marshal (existing behavior)
func (g *Generator) generateCopyMarshal() string {
	var code strings.Builder

	// Function signature
	code.WriteString(fmt.Sprintf("func (p *%s) MarshalLayout() ([]byte, error) {\n", g.analyzed.TypeName))
	code.WriteString(fmt.Sprintf("\tbuf := make([]byte, %d)\n", g.analyzed.BufferSize))

	// Declare offset only if we have dynamic regions or indirect slices
	hasDynamic := false
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.DynamicRegion {
			hasDynamic = true
			break
		}
	}
	if !hasDynamic && g.layout != nil {
		for _, field := range g.layout.Fields {
			if field.Layout.From != "" {
				hasDynamic = true
				break
			}
		}
	}
	if hasDynamic {
		code.WriteString("\tvar offset int\n")
	}
	code.WriteString("\n")

	// Generate code for each region
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.FixedRegion {
			code.WriteString(g.generateFixedMarshal(region))
		} else {
			code.WriteString(g.generateDynamicMarshal(region))
		}
	}

	// Generate indirect slice marshal ([][]byte with metadata indirection)
	if g.layout != nil {
		for _, field := range g.layout.Fields {
			if field.Layout.From != "" {
				code.WriteString(g.generateIndirectMarshal(field))
			}
		}
	}

	code.WriteString("\treturn buf, nil\n")
	code.WriteString("}\n")

	return code.String()
}

// generateZeroCopyMarshal generates zero-copy marshal that writes to p.buf
func (g *Generator) generateZeroCopyMarshal() string {
	var code strings.Builder

	// Generate New function if alignment required (at top)
	if g.align > 0 {
		code.WriteString(g.generateNewFunction())
		code.WriteString("\n")
	}

	code.WriteString(fmt.Sprintf("func (p *%s) MarshalLayout() ([]byte, error) {\n", g.analyzed.TypeName))

	// Generate code for each region, writing to p.buf
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.FixedRegion {
			code.WriteString(g.generateZeroCopyFixedMarshal(region))
		} else {
			code.WriteString(g.generateZeroCopyDynamicMarshal(region))
		}
	}

	code.WriteString("\treturn p.buf[:], nil\n")
	code.WriteString("}\n")

	return code.String()
}

// GenerateUnmarshal generates the UnmarshalLayout method
func (g *Generator) GenerateUnmarshal() string {
	if g.mode == "zerocopy" {
		return g.generateZeroCopyUnmarshal()
	}
	return g.generateCopyUnmarshal()
}

// generateCopyUnmarshal generates copy-mode unmarshal (existing behavior)
func (g *Generator) generateCopyUnmarshal() string {
	var code strings.Builder

	// Function signature
	code.WriteString(fmt.Sprintf("func (p *%s) UnmarshalLayout(buf []byte) error {\n", g.analyzed.TypeName))

	// Buffer size check
	code.WriteString(fmt.Sprintf("\tif len(buf) != %d {\n", g.analyzed.BufferSize))
	code.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"expected %d bytes, got %%d\", len(buf))\n", g.analyzed.BufferSize))
	code.WriteString("\t}\n\n")

	// Generate code for each region
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.FixedRegion {
			code.WriteString(g.generateFixedUnmarshal(region))
		} else {
			code.WriteString(g.generateDynamicUnmarshal(region))
		}
	}

	// Generate indirect slice unmarshal ([][]byte with metadata indirection)
	if g.layout != nil {
		for _, field := range g.layout.Fields {
			if field.Layout.From != "" {
				code.WriteString(g.generateIndirectUnmarshal(field))
			}
		}
	}

	code.WriteString("\treturn nil\n")
	code.WriteString("}\n")

	return code.String()
}

// generateZeroCopyUnmarshal generates zero-copy unmarshal using unsafe pointers
func (g *Generator) generateZeroCopyUnmarshal() string {
	var code strings.Builder

	// UnmarshalLayout: no params, assumes p.buf already loaded
	code.WriteString(fmt.Sprintf("func (p *%s) UnmarshalLayout() error {\n", g.analyzed.TypeName))

	// Generate code for each region
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.FixedRegion {
			code.WriteString(g.generateZeroCopyFixedUnmarshal(region))
		} else {
			code.WriteString(g.generateZeroCopyDynamicUnmarshal(region))
		}
	}

	code.WriteString("\treturn nil\n")
	code.WriteString("}\n\n")

	// Add LoadFrom helper
	code.WriteString(g.generateLoadFromHelper())

	return code.String()
}

// generateNewFunction generates New() constructor for aligned buffer allocation
func (g *Generator) generateNewFunction() string {
	var code strings.Builder
	requiredSize := g.analyzed.BufferSize + g.align - 1

	code.WriteString(fmt.Sprintf("func New() *%s {\n", g.analyzed.TypeName))
	code.WriteString(fmt.Sprintf("\tp := &%s{}\n", g.analyzed.TypeName))

	if g.allocator != "" {
		// Custom allocator with validation
		code.WriteString(fmt.Sprintf("\t// IMPORTANT: %s() must return a buffer of at least %d bytes\n", g.allocator, requiredSize))
		code.WriteString(fmt.Sprintf("\t// (%d bytes for data + %d bytes for %d-byte alignment)\n",
			g.analyzed.BufferSize, g.align-1, g.align))
		code.WriteString(fmt.Sprintf("\tp.backing = %s()\n", g.allocator))
		code.WriteString("\t\n")
		code.WriteString("\t// Validate buffer size to prevent out-of-bounds access\n")
		code.WriteString(fmt.Sprintf("\tif len(p.backing) < %d {\n", requiredSize))
		code.WriteString(fmt.Sprintf("\t\tpanic(fmt.Sprintf(\"%s returned buffer of %%d bytes, need at least %d\", len(p.backing)))\n",
			g.allocator, requiredSize))
		code.WriteString("\t}\n")
	} else {
		// Default allocation
		code.WriteString(fmt.Sprintf("\t// Allocate %d + %d to guarantee %d-byte alignment\n",
			g.analyzed.BufferSize, g.align-1, g.align))
		code.WriteString(fmt.Sprintf("\tp.backing = make([]byte, %d)\n", requiredSize))
	}

	code.WriteString("\t\n")
	code.WriteString(fmt.Sprintf("\t// Find %d-byte aligned offset\n", g.align))
	code.WriteString("\taddr := uintptr(unsafe.Pointer(&p.backing[0]))\n")
	code.WriteString(fmt.Sprintf("\toffset := int(((addr + %d) &^ %d) - addr)\n", g.align-1, g.align-1))
	code.WriteString("\t\n")
	code.WriteString("\t// Slice aligned region\n")
	code.WriteString(fmt.Sprintf("\tp.buf = p.backing[offset : offset+%d]\n", g.analyzed.BufferSize))
	code.WriteString("\treturn p\n")
	code.WriteString("}\n")

	return code.String()
}

// generateLoadFromHelper generates LoadFrom and WriteTo helpers for zerocopy mode
func (g *Generator) generateLoadFromHelper() string {
	var code strings.Builder

	// LoadFrom: read from io.Reader into p.buf
	code.WriteString(fmt.Sprintf("func (p *%s) LoadFrom(r io.Reader) error {\n", g.analyzed.TypeName))
	code.WriteString("\tif _, err := io.ReadFull(r, p.buf[:]); err != nil {\n")
	code.WriteString("\t\treturn err\n")
	code.WriteString("\t}\n")
	code.WriteString("\treturn p.UnmarshalLayout()\n")
	code.WriteString("}\n\n")

	// WriteTo: marshal and write p.buf to io.Writer
	code.WriteString(fmt.Sprintf("func (p *%s) WriteTo(w io.Writer) error {\n", g.analyzed.TypeName))
	code.WriteString("\tif _, err := p.MarshalLayout(); err != nil {\n")
	code.WriteString("\t\treturn err\n")
	code.WriteString("\t}\n")
	code.WriteString("\t_, err := w.Write(p.buf[:])\n")
	code.WriteString("\treturn err\n")
	code.WriteString("}\n")

	return code.String()
}

// generateFixedMarshal generates marshal code for a fixed-size field
func (g *Generator) generateFixedMarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	end := region.Boundary

	// Comment
	code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n", field.Name, field.GoType, start, end))

	// Generate appropriate binary operation based on type
	switch field.GoType {
	case "uint8", "int8", "byte":
		code.WriteString(fmt.Sprintf("\tbuf[%d] = p.%s\n\n", start, field.Name))

	case "uint16", "int16":
		putFunc := g.binaryPutFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\t%s.%s(buf[%d:%d], p.%s)\n\n",
			g.endianPrefix(), putFunc, start, end, field.Name))

	case "uint32", "int32":
		putFunc := g.binaryPutFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\t%s.%s(buf[%d:%d], p.%s)\n\n",
			g.endianPrefix(), putFunc, start, end, field.Name))

	case "uint64", "int64":
		putFunc := g.binaryPutFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\t%s.%s(buf[%d:%d], p.%s)\n\n",
			g.endianPrefix(), putFunc, start, end, field.Name))

	default:
		// Handle arrays
		if strings.HasPrefix(field.GoType, "[") && strings.Contains(field.GoType, "]byte") {
			code.WriteString(fmt.Sprintf("\tcopy(buf[%d:%d], p.%s[:])\n\n", start, end, field.Name))
		} else {
			// Handle struct types with MarshalLayout
			code.WriteString(fmt.Sprintf("\telemBuf, err := p.%s.MarshalLayout()\n", field.Name))
			code.WriteString("\tif err != nil {\n")
			code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"marshal %s: %%w\", err)\n", field.Name))
			code.WriteString("\t}\n")
			code.WriteString(fmt.Sprintf("\tcopy(buf[%d:%d], elemBuf)\n\n", start, end))
		}
	}

	return code.String()
}

// generateFixedUnmarshal generates unmarshal code for a fixed-size field
func (g *Generator) generateFixedUnmarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	end := region.Boundary

	// Comment
	code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n", field.Name, field.GoType, start, end))

	// Generate appropriate binary operation based on type
	switch field.GoType {
	case "uint8", "int8", "byte":
		code.WriteString(fmt.Sprintf("\tp.%s = buf[%d]\n\n", field.Name, start))

	case "uint16", "int16":
		getFunc := g.binaryGetFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\tp.%s = %s.%s(buf[%d:%d])\n\n",
			field.Name, g.endianPrefix(), getFunc, start, end))

	case "uint32", "int32":
		getFunc := g.binaryGetFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\tp.%s = %s.%s(buf[%d:%d])\n\n",
			field.Name, g.endianPrefix(), getFunc, start, end))

	case "uint64", "int64":
		getFunc := g.binaryGetFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\tp.%s = %s.%s(buf[%d:%d])\n\n",
			field.Name, g.endianPrefix(), getFunc, start, end))

	default:
		// Handle arrays
		if strings.HasPrefix(field.GoType, "[") && strings.Contains(field.GoType, "]byte") {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s[:], buf[%d:%d])\n\n", field.Name, start, end))
		} else {
			// Handle struct types with UnmarshalLayout
			code.WriteString(fmt.Sprintf("\tif err := p.%s.UnmarshalLayout(buf[%d:%d]); err != nil {\n",
				field.Name, start, end))
			code.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"unmarshal %s: %%w\", err)\n", field.Name))
			code.WriteString("\t}\n\n")
		}
	}

	return code.String()
}

// binaryPutFunc returns the binary.PutXXX function name for a type
func (g *Generator) binaryPutFunc(goType string) string {
	switch goType {
	case "uint16":
		return "PutUint16"
	case "uint32":
		return "PutUint32"
	case "uint64":
		return "PutUint64"
	case "int16":
		return "PutUint16"
	case "int32":
		return "PutUint32"
	case "int64":
		return "PutUint64"
	default:
		return "PutUint32" // fallback
	}
}

// binaryGetFunc returns the binary.Uint32() function name for a type
func (g *Generator) binaryGetFunc(goType string) string {
	switch goType {
	case "uint16":
		return "Uint16"
	case "uint32":
		return "Uint32"
	case "uint64":
		return "Uint64"
	case "int16":
		return "Uint16"
	case "int32":
		return "Uint32"
	case "int64":
		return "Uint64"
	default:
		return "Uint32" // fallback
	}
}

// endianPrefix returns "binary.LittleEndian" or "binary.BigEndian"
func (g *Generator) endianPrefix() string {
	if g.endian == "big" {
		return "binary.BigEndian"
	}
	return "binary.LittleEndian"
}

// generateDynamicMarshal generates marshal code for a dynamic field
func (g *Generator) generateDynamicMarshal(region analyzer.Region) string {
	// Check element type to determine marshal strategy
	if region.ElementType == "byte" {
		return g.generateByteMarshal(region)
	}
	return g.generateStructMarshal(region)
}

// generateByteMarshal generates byte-by-byte marshal for []byte
func (g *Generator) generateByteMarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s\n",
			field.Name, field.GoType, start, boundary, countField))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n",
			field.Name, field.GoType, start, boundary))
	}

	if region.Direction == parser.StartEnd {
		// Forward growth
		code.WriteString(fmt.Sprintf("\toffset = %d\n", start))

		// Count validation if count field exists
		if countField != "" {
			code.WriteString(fmt.Sprintf("\tif len(p.%s) != int(p.%s) {\n", field.Name, countField))
			code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"%s length mismatch: have %%d, want %%d\", len(p.%s), p.%s)\n",
				field.Name, field.Name, countField))
			code.WriteString("\t}\n")
		}

		// Marshal loop
		code.WriteString(fmt.Sprintf("\tfor i := range p.%s {\n", field.Name))
		code.WriteString(fmt.Sprintf("\t\tif offset >= %d {\n", boundary))
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"%s collision at offset %%d\", offset)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tbuf[offset] = p.%s[i]\n", field.Name))
		code.WriteString("\t\toffset++\n")
		code.WriteString("\t}\n\n")
	} else {
		// Backward growth (end-start)
		code.WriteString(fmt.Sprintf("\toffset = %d\n", start))

		// Count validation if count field exists
		if countField != "" {
			code.WriteString(fmt.Sprintf("\tif len(p.%s) != int(p.%s) {\n", field.Name, countField))
			code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"%s length mismatch: have %%d, want %%d\", len(p.%s), p.%s)\n",
				field.Name, field.Name, countField))
			code.WriteString("\t}\n")
		}

		// Marshal backward
		code.WriteString(fmt.Sprintf("\tfor i := len(p.%s) - 1; i >= 0; i-- {\n", field.Name))
		code.WriteString("\t\toffset--\n")
		code.WriteString(fmt.Sprintf("\t\tif offset < %d {\n", boundary))
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"%s collision at offset %%d\", offset)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tbuf[offset] = p.%s[i]\n", field.Name))
		code.WriteString("\t}\n\n")
	}

	return code.String()
}

// generateStructMarshal generates element-by-element marshal for []StructType
func (g *Generator) generateStructMarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField
	elementSize := region.ElementSize

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s (element size: %d)\n",
			field.Name, field.GoType, start, boundary, countField, elementSize))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) (element size: %d)\n",
			field.Name, field.GoType, start, boundary, elementSize))
	}

	if region.Direction == parser.StartEnd {
		// Forward growth
		code.WriteString(fmt.Sprintf("\toffset = %d\n", start))

		// Count validation if count field exists
		if countField != "" {
			code.WriteString(fmt.Sprintf("\tif len(p.%s) != int(p.%s) {\n", field.Name, countField))
			code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"%s length mismatch: have %%d, want %%d\", len(p.%s), p.%s)\n",
				field.Name, field.Name, countField))
			code.WriteString("\t}\n")
		}

		// Marshal loop for structs
		code.WriteString(fmt.Sprintf("\tfor i := range p.%s {\n", field.Name))
		code.WriteString(fmt.Sprintf("\t\tif offset + %d > %d {\n", elementSize, boundary))
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"%s collision at offset %%d\", offset)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\telemBuf, err := p.%s[i].MarshalLayout()\n", field.Name))
		code.WriteString("\t\tif err != nil {\n")
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"marshal %s[%%d]: %%w\", i, err)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tcopy(buf[offset:offset+%d], elemBuf)\n", elementSize))
		code.WriteString(fmt.Sprintf("\t\toffset += %d\n", elementSize))
		code.WriteString("\t}\n\n")
	} else {
		// Backward growth (end-start)
		code.WriteString(fmt.Sprintf("\toffset = %d\n", start))

		// Count validation if count field exists
		if countField != "" {
			code.WriteString(fmt.Sprintf("\tif len(p.%s) != int(p.%s) {\n", field.Name, countField))
			code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"%s length mismatch: have %%d, want %%d\", len(p.%s), p.%s)\n",
				field.Name, field.Name, countField))
			code.WriteString("\t}\n")
		}

		// Marshal backward for structs
		code.WriteString(fmt.Sprintf("\tfor i := len(p.%s) - 1; i >= 0; i-- {\n", field.Name))
		code.WriteString(fmt.Sprintf("\t\toffset -= %d\n", elementSize))
		code.WriteString(fmt.Sprintf("\t\tif offset < %d {\n", boundary))
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"%s collision at offset %%d\", offset)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\telemBuf, err := p.%s[i].MarshalLayout()\n", field.Name))
		code.WriteString("\t\tif err != nil {\n")
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"marshal %s[%%d]: %%w\", i, err)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tcopy(buf[offset:offset+%d], elemBuf)\n", elementSize))
		code.WriteString("\t}\n\n")
	}

	return code.String()
}

// generateDynamicUnmarshal generates unmarshal code for a dynamic field
func (g *Generator) generateDynamicUnmarshal(region analyzer.Region) string {
	// Check element type to determine unmarshal strategy
	if region.ElementType == "byte" {
		return g.generateByteUnmarshal(region)
	}
	return g.generateStructUnmarshal(region)
}

// generateByteUnmarshal generates byte-by-byte unmarshal for []byte
func (g *Generator) generateByteUnmarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s\n",
			field.Name, field.GoType, start, boundary, countField))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n",
			field.Name, field.GoType, start, boundary))
	}

	// Calculate length
	if countField != "" {
		// Explicit count
		code.WriteString(fmt.Sprintf("\t// Reuse buffer if capacity allows\n"))
		code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= int(p.%s) {\n", field.Name, countField))
		code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:p.%s]\n", field.Name, field.Name, countField))
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tp.%s = make([]byte, p.%s)\n", field.Name, countField))
		code.WriteString("\t}\n")

		if region.Direction == parser.StartEnd {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d:%d+p.%s])\n\n", field.Name, start, start, countField))
		} else {
			// Backward: copy from (start - count) to start
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d-p.%s:%d])\n\n", field.Name, start, countField, start))
		}
	} else {
		// Implicit length from boundaries
		lenVar := fmt.Sprintf("%sLen", strings.ToLower(string(field.Name[0])))
		if region.Direction == parser.StartEnd {
			code.WriteString(fmt.Sprintf("\t%s := %d - %d\n", lenVar, boundary, start))
		} else {
			code.WriteString(fmt.Sprintf("\t%s := %d - %d\n", lenVar, start, boundary))
		}

		code.WriteString(fmt.Sprintf("\t// Reuse buffer if capacity allows\n"))
		code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= %s {\n", field.Name, lenVar))
		code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:%s]\n", field.Name, field.Name, lenVar))
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tp.%s = make([]byte, %s)\n", field.Name, lenVar))
		code.WriteString("\t}\n")

		if region.Direction == parser.StartEnd {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d:%d])\n\n", field.Name, start, boundary))
		} else {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d:%d])\n\n", field.Name, boundary, start))
		}
	}

	return code.String()
}

// generateStructUnmarshal generates element-by-element unmarshal for []StructType
func (g *Generator) generateStructUnmarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField
	elementSize := region.ElementSize
	elementType := region.ElementType

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s (element size: %d)\n",
			field.Name, field.GoType, start, boundary, countField, elementSize))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) (element size: %d)\n",
			field.Name, field.GoType, start, boundary, elementSize))
	}

	// Calculate number of elements
	if countField != "" {
		// Explicit count
		code.WriteString(fmt.Sprintf("\t// Reuse slice if capacity allows\n"))
		code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= int(p.%s) {\n", field.Name, countField))
		code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:p.%s]\n", field.Name, field.Name, countField))
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tp.%s = make([]%s, p.%s)\n", field.Name, elementType, countField))
		code.WriteString("\t}\n")
	} else {
		// Implicit count from region size
		numElements := (boundary - start) / elementSize
		if region.Direction == parser.EndStart {
			numElements = (start - boundary) / elementSize
		}
		code.WriteString(fmt.Sprintf("\tnumElements := %d // (%d bytes / %d bytes per element)\n",
			numElements, abs(boundary-start), elementSize))
		code.WriteString(fmt.Sprintf("\t// Reuse slice if capacity allows\n"))
		code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= numElements {\n", field.Name))
		code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:numElements]\n", field.Name, field.Name))
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tp.%s = make([]%s, numElements)\n", field.Name, elementType))
		code.WriteString("\t}\n")
	}

	// Unmarshal loop
	code.WriteString(fmt.Sprintf("\toffset := %d\n", start))
	code.WriteString(fmt.Sprintf("\tfor i := range p.%s {\n", field.Name))

	if region.Direction == parser.StartEnd {
		code.WriteString(fmt.Sprintf("\t\tif err := p.%s[i].UnmarshalLayout(buf[offset:offset+%d]); err != nil {\n",
			field.Name, elementSize))
		code.WriteString(fmt.Sprintf("\t\t\treturn fmt.Errorf(\"unmarshal %s[%%d]: %%w\", i, err)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\toffset += %d\n", elementSize))
	} else {
		// Backward
		code.WriteString(fmt.Sprintf("\t\tif err := p.%s[i].UnmarshalLayout(buf[offset-%d:offset]); err != nil {\n",
			field.Name, elementSize))
		code.WriteString(fmt.Sprintf("\t\t\treturn fmt.Errorf(\"unmarshal %s[%%d]: %%w\", i, err)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\toffset -= %d\n", elementSize))
	}

	code.WriteString("\t}\n\n")

	return code.String()
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

// generateZeroCopyFixedUnmarshal generates zero-copy unmarshal for fixed-size field
func (g *Generator) generateZeroCopyFixedUnmarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	end := region.Boundary

	code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n", field.Name, field.GoType, start, end))

	switch field.GoType {
	case "uint8", "int8", "byte":
		code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d]\n\n", field.Name, start))

	case "uint16":
		code.WriteString(fmt.Sprintf("\tp.%s = *(*uint16)(unsafe.Pointer(&p.buf[%d]))\n\n",
			field.Name, start))

	case "int16":
		code.WriteString(fmt.Sprintf("\tp.%s = *(*int16)(unsafe.Pointer(&p.buf[%d]))\n\n",
			field.Name, start))

	case "uint32":
		code.WriteString(fmt.Sprintf("\tp.%s = *(*uint32)(unsafe.Pointer(&p.buf[%d]))\n\n",
			field.Name, start))

	case "int32":
		code.WriteString(fmt.Sprintf("\tp.%s = *(*int32)(unsafe.Pointer(&p.buf[%d]))\n\n",
			field.Name, start))

	case "uint64":
		code.WriteString(fmt.Sprintf("\tp.%s = *(*uint64)(unsafe.Pointer(&p.buf[%d]))\n\n",
			field.Name, start))

	case "int64":
		code.WriteString(fmt.Sprintf("\tp.%s = *(*int64)(unsafe.Pointer(&p.buf[%d]))\n\n",
			field.Name, start))

	default:
		code.WriteString(fmt.Sprintf("\t// TODO: zerocopy unmarshal %s\n\n", field.GoType))
	}

	return code.String()
}

// generateZeroCopyDynamicUnmarshal generates zero-copy unmarshal for dynamic field
func (g *Generator) generateZeroCopyDynamicUnmarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField

	// Only handle []byte for now
	if field.GoType != "[]byte" {
		code.WriteString(fmt.Sprintf("\t// TODO: zerocopy unmarshal dynamic %s\n\n", field.GoType))
		return code.String()
	}

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s\n",
			field.Name, field.GoType, start, boundary, countField))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n",
			field.Name, field.GoType, start, boundary))
	}

	// Slice directly into buffer
	if countField != "" {
		// Count-dependent slicing
		if region.Direction == parser.StartEnd {
			// Forward: slice from start with count
			code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d:%d+p.%s]\n\n", field.Name, start, start, countField))
		} else {
			// Backward: slice from (start - count) to start
			code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d-p.%s:%d]\n\n", field.Name, start, countField, start))
		}
	} else {
		// Implicit length from boundaries
		if region.Direction == parser.StartEnd {
			code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d:%d]\n\n", field.Name, start, boundary))
		} else {
			code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d:%d]\n\n", field.Name, boundary, start))
		}
	}

	return code.String()
}

// generateZeroCopyFixedMarshal generates marshal code for fixed field into p.buf
func (g *Generator) generateZeroCopyFixedMarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	end := region.Boundary

	code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n", field.Name, field.GoType, start, end))

	switch field.GoType {
	case "uint8", "int8", "byte":
		code.WriteString(fmt.Sprintf("\tp.buf[%d] = p.%s\n\n", start, field.Name))

	case "uint16":
		code.WriteString(fmt.Sprintf("\t*(*uint16)(unsafe.Pointer(&p.buf[%d])) = p.%s\n\n",
			start, field.Name))

	case "int16":
		code.WriteString(fmt.Sprintf("\t*(*int16)(unsafe.Pointer(&p.buf[%d])) = p.%s\n\n",
			start, field.Name))

	case "uint32":
		code.WriteString(fmt.Sprintf("\t*(*uint32)(unsafe.Pointer(&p.buf[%d])) = p.%s\n\n",
			start, field.Name))

	case "int32":
		code.WriteString(fmt.Sprintf("\t*(*int32)(unsafe.Pointer(&p.buf[%d])) = p.%s\n\n",
			start, field.Name))

	case "uint64":
		code.WriteString(fmt.Sprintf("\t*(*uint64)(unsafe.Pointer(&p.buf[%d])) = p.%s\n\n",
			start, field.Name))

	case "int64":
		code.WriteString(fmt.Sprintf("\t*(*int64)(unsafe.Pointer(&p.buf[%d])) = p.%s\n\n",
			start, field.Name))

	default:
		if strings.HasPrefix(field.GoType, "[") && strings.Contains(field.GoType, "]byte") {
			code.WriteString(fmt.Sprintf("\tcopy(p.buf[%d:%d], p.%s[:])\n\n", start, end, field.Name))
		} else {
			code.WriteString(fmt.Sprintf("\t// TODO: zerocopy marshal %s\n\n", field.GoType))
		}
	}

	return code.String()
}

// generateZeroCopyDynamicMarshal generates marshal code for dynamic field into p.buf
func (g *Generator) generateZeroCopyDynamicMarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField

	// Only handle []byte for now
	if field.GoType != "[]byte" {
		code.WriteString(fmt.Sprintf("\t// TODO: zerocopy marshal dynamic %s\n\n", field.GoType))
		return code.String()
	}

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s\n",
			field.Name, field.GoType, start, boundary, countField))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n",
			field.Name, field.GoType, start, boundary))
	}

	// Since Body is a slice into p.buf[], it's already in the right place.
	// But we might need to copy if it was modified.
	// For now, just note that fields should reference p.buf directly.
	code.WriteString(fmt.Sprintf("\t// %s is already sliced from p.buf, no copy needed\n\n", field.Name))

	return code.String()
}

// generateIndirectUnmarshal generates unmarshal code for [][]byte with metadata indirection
func (g *Generator) generateIndirectUnmarshal(field parser.Field) string {
	var code strings.Builder

	// Comment
	code.WriteString(fmt.Sprintf("\t// %s: [][]byte from=%s offset=%s size=%s region=%s\n",
		field.Name, field.Layout.From, field.Layout.OffsetField, field.Layout.SizeField, field.Layout.Region))

	// Allocate slice matching source length
	code.WriteString(fmt.Sprintf("\t// Reuse slice if capacity allows\n"))
	code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= len(p.%s) {\n", field.Name, field.Layout.From))
	code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:len(p.%s)]\n", field.Name, field.Name, field.Layout.From))
	code.WriteString("\t} else {\n")
	code.WriteString(fmt.Sprintf("\t\tp.%s = make([][]byte, len(p.%s))\n", field.Name, field.Layout.From))
	code.WriteString("\t}\n")

	// Loop through source elements and create slices
	code.WriteString(fmt.Sprintf("\tfor i := range p.%s {\n", field.Layout.From))
	code.WriteString(fmt.Sprintf("\t\toffset := int(p.%s[i].%s)\n", field.Layout.From, field.Layout.OffsetField))
	code.WriteString(fmt.Sprintf("\t\tsize := int(p.%s[i].%s)\n", field.Layout.From, field.Layout.SizeField))
	code.WriteString(fmt.Sprintf("\t\tp.%s[i] = buf[offset:offset+size]\n", field.Name))
	code.WriteString("\t}\n\n")

	return code.String()
}

// generateIndirectMarshal generates marshal code for [][]byte with backward packing
func (g *Generator) generateIndirectMarshal(field parser.Field) string {
	var code strings.Builder

	// Comment
	code.WriteString(fmt.Sprintf("\t// %s: [][]byte packed backward into %s, updating %s metadata\n",
		field.Name, field.Layout.Region, field.Layout.From))

	// Find the region field to determine pack start point
	var regionField *parser.Field
	for i := range g.layout.Fields {
		if g.layout.Fields[i].Name == field.Layout.Region {
			regionField = &g.layout.Fields[i]
			break
		}
	}

	// Pack backward from region end
	var packStart string
	if regionField != nil && regionField.Layout.Direction == parser.EndStart {
		// Region is end-start, so it starts at bufferSize and grows backward
		packStart = fmt.Sprintf("%d", g.analyzed.BufferSize)
	} else {
		// Default: pack from buffer end
		packStart = fmt.Sprintf("%d", g.analyzed.BufferSize)
	}

	code.WriteString(fmt.Sprintf("\toffset = %s\n", packStart))
	code.WriteString(fmt.Sprintf("\tfor i := len(p.%s) - 1; i >= 0; i-- {\n", field.Name))
	code.WriteString(fmt.Sprintf("\t\tsize := len(p.%s[i])\n", field.Name))
	code.WriteString("\t\toffset -= size\n")
	code.WriteString(fmt.Sprintf("\t\tcopy(buf[offset:offset+size], p.%s[i])\n", field.Name))
	code.WriteString(fmt.Sprintf("\t\tp.%s[i].%s = uint32(offset)\n", field.Layout.From, field.Layout.OffsetField))
	code.WriteString(fmt.Sprintf("\t\tp.%s[i].%s = uint32(size)\n", field.Layout.From, field.Layout.SizeField))
	code.WriteString("\t}\n\n")

	return code.String()
}
