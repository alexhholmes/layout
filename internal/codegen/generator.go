package codegen

import (
	"fmt"
	"strings"

	"github.com/alexhholmes/layout/internal/analyzer"
	"github.com/alexhholmes/layout/internal/parser"
)

// Generator generates marshal/unmarshal code for binary layouts
type Generator struct {
	analyzed  *analyzer.AnalyzedLayout
	registry  *analyzer.TypeRegistry
	endian    string // "little" or "big"
	mode      string // "copy" or "zerocopy"
	align     int    // alignment requirement (0 = none)
	allocator string // custom allocator function name (optional)
}

// NewGenerator creates a new code generator
func NewGenerator(analyzed *analyzer.AnalyzedLayout, reg *analyzer.TypeRegistry, endian string, mode string, align int, allocator string) *Generator {
	if endian == "" {
		endian = "little"
	}
	if mode == "" {
		mode = "copy"
	}
	return &Generator{
		analyzed:  analyzed,
		registry:  reg,
		endian:    endian,
		mode:      mode,
		align:     align,
		allocator: allocator,
	}
}

// Generate returns the complete generated file content
func (g *Generator) Generate() (string, error) {
	var out strings.Builder

	// Package comment
	out.WriteString("// Code generated by layout. DO NOT EDIT.\n\n")
	out.WriteString("package main\n\n")

	// Imports
	out.WriteString("import (\n")
	if g.mode != "zerocopy" {
		out.WriteString("\t\"encoding/binary\"\n")
		out.WriteString("\t\"fmt\"\n")
	}
	if g.mode == "zerocopy" {
		out.WriteString("\t\"fmt\"\n")
		out.WriteString("\t\"io\"\n")
		out.WriteString("\t\"unsafe\"\n")
	}
	out.WriteString(")\n\n")

	// Generate marshal method
	marshal := g.GenerateMarshal()
	out.WriteString(marshal)
	out.WriteString("\n")

	// Generate unmarshal method
	unmarshal := g.GenerateUnmarshal()
	out.WriteString(unmarshal)

	return out.String(), nil
}

// GenerateMarshal generates the MarshalLayout method
func (g *Generator) GenerateMarshal() string {
	if g.mode == "zerocopy" {
		return g.generateZeroCopyMarshal()
	}
	return g.generateCopyMarshal()
}

// generateCopyMarshal generates copy-mode marshal (existing behavior)
func (g *Generator) generateCopyMarshal() string {
	var code strings.Builder

	// Function signature
	code.WriteString(fmt.Sprintf("func (p *%s) MarshalLayout() ([]byte, error) {\n", g.analyzed.TypeName))
	code.WriteString(fmt.Sprintf("\tbuf := make([]byte, %d)\n\n", g.analyzed.BufferSize))

	// Generate code for each region
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.FixedRegion {
			code.WriteString(g.generateFixedMarshal(region))
		} else {
			code.WriteString(g.generateDynamicMarshal(region))
		}
	}

	code.WriteString("\treturn buf, nil\n")
	code.WriteString("}\n")

	return code.String()
}

// generateZeroCopyMarshal generates zero-copy marshal that writes to p.buf
func (g *Generator) generateZeroCopyMarshal() string {
	var code strings.Builder

	// Generate New function if alignment required (at top)
	if g.align > 0 {
		code.WriteString(g.generateNewFunction())
		code.WriteString("\n")
	}

	code.WriteString(fmt.Sprintf("func (p *%s) MarshalLayout() ([]byte, error) {\n", g.analyzed.TypeName))

	// Generate code for each region, writing to p.buf
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.FixedRegion {
			code.WriteString(g.generateZeroCopyFixedMarshal(region))
		} else {
			code.WriteString(g.generateZeroCopyDynamicMarshal(region))
		}
	}

	code.WriteString("\treturn p.buf[:], nil\n")
	code.WriteString("}\n")

	return code.String()
}

// GenerateUnmarshal generates the UnmarshalLayout method
func (g *Generator) GenerateUnmarshal() string {
	if g.mode == "zerocopy" {
		return g.generateZeroCopyUnmarshal()
	}
	return g.generateCopyUnmarshal()
}

// generateCopyUnmarshal generates copy-mode unmarshal (existing behavior)
func (g *Generator) generateCopyUnmarshal() string {
	var code strings.Builder

	// Function signature
	code.WriteString(fmt.Sprintf("func (p *%s) UnmarshalLayout(buf []byte) error {\n", g.analyzed.TypeName))

	// Buffer size check
	code.WriteString(fmt.Sprintf("\tif len(buf) != %d {\n", g.analyzed.BufferSize))
	code.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"expected %d bytes, got %%d\", len(buf))\n", g.analyzed.BufferSize))
	code.WriteString("\t}\n\n")

	// Generate code for each region
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.FixedRegion {
			code.WriteString(g.generateFixedUnmarshal(region))
		} else {
			code.WriteString(g.generateDynamicUnmarshal(region))
		}
	}

	code.WriteString("\treturn nil\n")
	code.WriteString("}\n")

	return code.String()
}

// generateZeroCopyUnmarshal generates zero-copy unmarshal using unsafe pointers
func (g *Generator) generateZeroCopyUnmarshal() string {
	var code strings.Builder

	// UnmarshalLayout: no params, assumes p.buf already loaded
	code.WriteString(fmt.Sprintf("func (p *%s) UnmarshalLayout() error {\n", g.analyzed.TypeName))

	// Generate code for each region
	for _, region := range g.analyzed.Regions {
		if region.Kind == analyzer.FixedRegion {
			code.WriteString(g.generateZeroCopyFixedUnmarshal(region))
		} else {
			code.WriteString(g.generateZeroCopyDynamicUnmarshal(region))
		}
	}

	code.WriteString("\treturn nil\n")
	code.WriteString("}\n\n")

	// Add LoadFrom helper
	code.WriteString(g.generateLoadFromHelper())

	return code.String()
}

// generateNewFunction generates New() constructor for aligned buffer allocation
func (g *Generator) generateNewFunction() string {
	var code strings.Builder
	requiredSize := g.analyzed.BufferSize + g.align - 1

	code.WriteString(fmt.Sprintf("func New() *%s {\n", g.analyzed.TypeName))
	code.WriteString(fmt.Sprintf("\tp := &%s{}\n", g.analyzed.TypeName))

	if g.allocator != "" {
		// Custom allocator with validation
		code.WriteString(fmt.Sprintf("\t// IMPORTANT: %s() must return a buffer of at least %d bytes\n", g.allocator, requiredSize))
		code.WriteString(fmt.Sprintf("\t// (%d bytes for data + %d bytes for %d-byte alignment)\n",
			g.analyzed.BufferSize, g.align-1, g.align))
		code.WriteString(fmt.Sprintf("\tp.backing = %s()\n", g.allocator))
		code.WriteString("\t\n")
		code.WriteString("\t// Validate buffer size to prevent out-of-bounds access\n")
		code.WriteString(fmt.Sprintf("\tif len(p.backing) < %d {\n", requiredSize))
		code.WriteString(fmt.Sprintf("\t\tpanic(fmt.Sprintf(\"%s returned buffer of %%d bytes, need at least %d\", len(p.backing)))\n",
			g.allocator, requiredSize))
		code.WriteString("\t}\n")
	} else {
		// Default allocation
		code.WriteString(fmt.Sprintf("\t// Allocate %d + %d to guarantee %d-byte alignment\n",
			g.analyzed.BufferSize, g.align-1, g.align))
		code.WriteString(fmt.Sprintf("\tp.backing = make([]byte, %d)\n", requiredSize))
	}

	code.WriteString("\t\n")
	code.WriteString(fmt.Sprintf("\t// Find %d-byte aligned offset\n", g.align))
	code.WriteString("\taddr := uintptr(unsafe.Pointer(&p.backing[0]))\n")
	code.WriteString(fmt.Sprintf("\toffset := int(((addr + %d) &^ %d) - addr)\n", g.align-1, g.align-1))
	code.WriteString("\t\n")
	code.WriteString("\t// Slice aligned region\n")
	code.WriteString(fmt.Sprintf("\tp.buf = p.backing[offset : offset+%d]\n", g.analyzed.BufferSize))
	code.WriteString("\treturn p\n")
	code.WriteString("}\n")

	return code.String()
}

// generateLoadFromHelper generates LoadFrom and WriteTo helpers for zerocopy mode
func (g *Generator) generateLoadFromHelper() string {
	var code strings.Builder

	// LoadFrom: read from io.Reader into p.buf
	code.WriteString(fmt.Sprintf("func (p *%s) LoadFrom(r io.Reader) error {\n", g.analyzed.TypeName))
	code.WriteString("\tif _, err := io.ReadFull(r, p.buf[:]); err != nil {\n")
	code.WriteString("\t\treturn err\n")
	code.WriteString("\t}\n")
	code.WriteString("\treturn p.UnmarshalLayout()\n")
	code.WriteString("}\n\n")

	// WriteTo: marshal and write p.buf to io.Writer
	code.WriteString(fmt.Sprintf("func (p *%s) WriteTo(w io.Writer) error {\n", g.analyzed.TypeName))
	code.WriteString("\tif _, err := p.MarshalLayout(); err != nil {\n")
	code.WriteString("\t\treturn err\n")
	code.WriteString("\t}\n")
	code.WriteString("\t_, err := w.Write(p.buf[:])\n")
	code.WriteString("\treturn err\n")
	code.WriteString("}\n")

	return code.String()
}

// generateFixedMarshal generates marshal code for a fixed-size field
func (g *Generator) generateFixedMarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	end := region.Boundary

	// Comment
	code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n", field.Name, field.GoType, start, end))

	// Generate appropriate binary operation based on type
	switch field.GoType {
	case "uint8", "int8", "byte":
		code.WriteString(fmt.Sprintf("\tbuf[%d] = p.%s\n\n", start, field.Name))

	case "uint16", "int16":
		putFunc := g.binaryPutFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\t%s.%s(buf[%d:%d], p.%s)\n\n",
			g.endianPrefix(), putFunc, start, end, field.Name))

	case "uint32", "int32":
		putFunc := g.binaryPutFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\t%s.%s(buf[%d:%d], p.%s)\n\n",
			g.endianPrefix(), putFunc, start, end, field.Name))

	case "uint64", "int64":
		putFunc := g.binaryPutFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\t%s.%s(buf[%d:%d], p.%s)\n\n",
			g.endianPrefix(), putFunc, start, end, field.Name))

	default:
		// Handle arrays
		if strings.HasPrefix(field.GoType, "[") && strings.Contains(field.GoType, "]byte") {
			code.WriteString(fmt.Sprintf("\tcopy(buf[%d:%d], p.%s[:])\n\n", start, end, field.Name))
		} else {
			code.WriteString(fmt.Sprintf("\t// TODO: marshal %s\n\n", field.GoType))
		}
	}

	return code.String()
}

// generateFixedUnmarshal generates unmarshal code for a fixed-size field
func (g *Generator) generateFixedUnmarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	end := region.Boundary

	// Comment
	code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n", field.Name, field.GoType, start, end))

	// Generate appropriate binary operation based on type
	switch field.GoType {
	case "uint8", "int8", "byte":
		code.WriteString(fmt.Sprintf("\tp.%s = buf[%d]\n\n", field.Name, start))

	case "uint16", "int16":
		getFunc := g.binaryGetFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\tp.%s = %s.%s(buf[%d:%d])\n\n",
			field.Name, g.endianPrefix(), getFunc, start, end))

	case "uint32", "int32":
		getFunc := g.binaryGetFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\tp.%s = %s.%s(buf[%d:%d])\n\n",
			field.Name, g.endianPrefix(), getFunc, start, end))

	case "uint64", "int64":
		getFunc := g.binaryGetFunc(field.GoType)
		code.WriteString(fmt.Sprintf("\tp.%s = %s.%s(buf[%d:%d])\n\n",
			field.Name, g.endianPrefix(), getFunc, start, end))

	default:
		// Handle arrays
		if strings.HasPrefix(field.GoType, "[") && strings.Contains(field.GoType, "]byte") {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s[:], buf[%d:%d])\n\n", field.Name, start, end))
		} else {
			code.WriteString(fmt.Sprintf("\t// TODO: unmarshal %s\n\n", field.GoType))
		}
	}

	return code.String()
}

// binaryPutFunc returns the binary.PutXXX function name for a type
func (g *Generator) binaryPutFunc(goType string) string {
	switch goType {
	case "uint16":
		return "PutUint16"
	case "uint32":
		return "PutUint32"
	case "uint64":
		return "PutUint64"
	case "int16":
		return "PutUint16"
	case "int32":
		return "PutUint32"
	case "int64":
		return "PutUint64"
	default:
		return "PutUint32" // fallback
	}
}

// binaryGetFunc returns the binary.Uint32() function name for a type
func (g *Generator) binaryGetFunc(goType string) string {
	switch goType {
	case "uint16":
		return "Uint16"
	case "uint32":
		return "Uint32"
	case "uint64":
		return "Uint64"
	case "int16":
		return "Uint16"
	case "int32":
		return "Uint32"
	case "int64":
		return "Uint64"
	default:
		return "Uint32" // fallback
	}
}

// endianPrefix returns "binary.LittleEndian" or "binary.BigEndian"
func (g *Generator) endianPrefix() string {
	if g.endian == "big" {
		return "binary.BigEndian"
	}
	return "binary.LittleEndian"
}

// generateDynamicMarshal generates marshal code for a dynamic field
func (g *Generator) generateDynamicMarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField

	// Only handle []byte for now
	if field.GoType != "[]byte" {
		code.WriteString(fmt.Sprintf("\t// TODO: marshal dynamic %s\n\n", field.GoType))
		return code.String()
	}

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s\n",
			field.Name, field.GoType, start, boundary, countField))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n",
			field.Name, field.GoType, start, boundary))
	}

	if region.Direction == parser.StartEnd {
		// Forward growth
		code.WriteString(fmt.Sprintf("\toffset := %d\n", start))

		// Count validation if count field exists
		if countField != "" {
			code.WriteString(fmt.Sprintf("\tif len(p.%s) != int(p.%s) {\n", field.Name, countField))
			code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"%s length mismatch: have %%d, want %%d\", len(p.%s), p.%s)\n",
				field.Name, field.Name, countField))
			code.WriteString("\t}\n")
		}

		// Marshal loop
		code.WriteString(fmt.Sprintf("\tfor i := range p.%s {\n", field.Name))
		code.WriteString(fmt.Sprintf("\t\tif offset >= %d {\n", boundary))
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"%s collision at offset %%d\", offset)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tbuf[offset] = p.%s[i]\n", field.Name))
		code.WriteString("\t\toffset++\n")
		code.WriteString("\t}\n\n")
	} else {
		// Backward growth (end-start)
		code.WriteString(fmt.Sprintf("\toffset := %d\n", start))

		// Count validation if count field exists
		if countField != "" {
			code.WriteString(fmt.Sprintf("\tif len(p.%s) != int(p.%s) {\n", field.Name, countField))
			code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"%s length mismatch: have %%d, want %%d\", len(p.%s), p.%s)\n",
				field.Name, field.Name, countField))
			code.WriteString("\t}\n")
		}

		// Marshal backward
		code.WriteString(fmt.Sprintf("\tfor i := len(p.%s) - 1; i >= 0; i-- {\n", field.Name))
		code.WriteString("\t\toffset--\n")
		code.WriteString(fmt.Sprintf("\t\tif offset < %d {\n", boundary))
		code.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"%s collision at offset %%d\", offset)\n", field.Name))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tbuf[offset] = p.%s[i]\n", field.Name))
		code.WriteString("\t}\n\n")
	}

	return code.String()
}

// generateDynamicUnmarshal generates unmarshal code for a dynamic field
func (g *Generator) generateDynamicUnmarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField

	// Only handle []byte for now
	if field.GoType != "[]byte" {
		code.WriteString(fmt.Sprintf("\t// TODO: unmarshal dynamic %s\n\n", field.GoType))
		return code.String()
	}

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s\n",
			field.Name, field.GoType, start, boundary, countField))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n",
			field.Name, field.GoType, start, boundary))
	}

	// Calculate length
	if countField != "" {
		// Explicit count
		code.WriteString(fmt.Sprintf("\t// Reuse buffer if capacity allows\n"))
		code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= int(p.%s) {\n", field.Name, countField))
		code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:p.%s]\n", field.Name, field.Name, countField))
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tp.%s = make([]byte, p.%s)\n", field.Name, countField))
		code.WriteString("\t}\n")

		if region.Direction == parser.StartEnd {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d:%d+p.%s])\n\n", field.Name, start, start, countField))
		} else {
			// Backward: copy from (start - count) to start
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d-p.%s:%d])\n\n", field.Name, start, countField, start))
		}
	} else {
		// Implicit length from boundaries
		lenVar := fmt.Sprintf("%sLen", strings.ToLower(string(field.Name[0])))
		if region.Direction == parser.StartEnd {
			code.WriteString(fmt.Sprintf("\t%s := %d - %d\n", lenVar, boundary, start))
		} else {
			code.WriteString(fmt.Sprintf("\t%s := %d - %d\n", lenVar, start, boundary))
		}

		code.WriteString(fmt.Sprintf("\t// Reuse buffer if capacity allows\n"))
		code.WriteString(fmt.Sprintf("\tif cap(p.%s) >= %s {\n", field.Name, lenVar))
		code.WriteString(fmt.Sprintf("\t\tp.%s = p.%s[:%s]\n", field.Name, field.Name, lenVar))
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tp.%s = make([]byte, %s)\n", field.Name, lenVar))
		code.WriteString("\t}\n")

		if region.Direction == parser.StartEnd {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d:%d])\n\n", field.Name, start, boundary))
		} else {
			code.WriteString(fmt.Sprintf("\tcopy(p.%s, buf[%d:%d])\n\n", field.Name, boundary, start))
		}
	}

	return code.String()
}

// generateZeroCopyFixedUnmarshal generates zero-copy unmarshal for fixed-size field
func (g *Generator) generateZeroCopyFixedUnmarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	end := region.Boundary

	code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n", field.Name, field.GoType, start, end))

	switch field.GoType {
	case "uint8", "int8", "byte":
		code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d]\n\n", field.Name, start))

	case "uint16":
		code.WriteString(fmt.Sprintf("\tp.%s = *(*uint16)(unsafe.Pointer(&p.buf[%d]))\n\n",
			field.Name, start))

	case "int16":
		code.WriteString(fmt.Sprintf("\tp.%s = *(*int16)(unsafe.Pointer(&p.buf[%d]))\n\n",
			field.Name, start))

	case "uint32":
		code.WriteString(fmt.Sprintf("\tp.%s = *(*uint32)(unsafe.Pointer(&p.buf[%d]))\n\n",
			field.Name, start))

	case "int32":
		code.WriteString(fmt.Sprintf("\tp.%s = *(*int32)(unsafe.Pointer(&p.buf[%d]))\n\n",
			field.Name, start))

	case "uint64":
		code.WriteString(fmt.Sprintf("\tp.%s = *(*uint64)(unsafe.Pointer(&p.buf[%d]))\n\n",
			field.Name, start))

	case "int64":
		code.WriteString(fmt.Sprintf("\tp.%s = *(*int64)(unsafe.Pointer(&p.buf[%d]))\n\n",
			field.Name, start))

	default:
		code.WriteString(fmt.Sprintf("\t// TODO: zerocopy unmarshal %s\n\n", field.GoType))
	}

	return code.String()
}

// generateZeroCopyDynamicUnmarshal generates zero-copy unmarshal for dynamic field
func (g *Generator) generateZeroCopyDynamicUnmarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField

	// Only handle []byte for now
	if field.GoType != "[]byte" {
		code.WriteString(fmt.Sprintf("\t// TODO: zerocopy unmarshal dynamic %s\n\n", field.GoType))
		return code.String()
	}

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s\n",
			field.Name, field.GoType, start, boundary, countField))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n",
			field.Name, field.GoType, start, boundary))
	}

	// Slice directly into buffer
	if countField != "" {
		// Count-dependent slicing
		if region.Direction == parser.StartEnd {
			// Forward: slice from start with count
			code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d:%d+p.%s]\n\n", field.Name, start, start, countField))
		} else {
			// Backward: slice from (start - count) to start
			code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d-p.%s:%d]\n\n", field.Name, start, countField, start))
		}
	} else {
		// Implicit length from boundaries
		if region.Direction == parser.StartEnd {
			code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d:%d]\n\n", field.Name, start, boundary))
		} else {
			code.WriteString(fmt.Sprintf("\tp.%s = p.buf[%d:%d]\n\n", field.Name, boundary, start))
		}
	}

	return code.String()
}

// generateZeroCopyFixedMarshal generates marshal code for fixed field into p.buf
func (g *Generator) generateZeroCopyFixedMarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	end := region.Boundary

	code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n", field.Name, field.GoType, start, end))

	switch field.GoType {
	case "uint8", "int8", "byte":
		code.WriteString(fmt.Sprintf("\tp.buf[%d] = p.%s\n\n", start, field.Name))

	case "uint16":
		code.WriteString(fmt.Sprintf("\t*(*uint16)(unsafe.Pointer(&p.buf[%d])) = p.%s\n\n",
			start, field.Name))

	case "int16":
		code.WriteString(fmt.Sprintf("\t*(*int16)(unsafe.Pointer(&p.buf[%d])) = p.%s\n\n",
			start, field.Name))

	case "uint32":
		code.WriteString(fmt.Sprintf("\t*(*uint32)(unsafe.Pointer(&p.buf[%d])) = p.%s\n\n",
			start, field.Name))

	case "int32":
		code.WriteString(fmt.Sprintf("\t*(*int32)(unsafe.Pointer(&p.buf[%d])) = p.%s\n\n",
			start, field.Name))

	case "uint64":
		code.WriteString(fmt.Sprintf("\t*(*uint64)(unsafe.Pointer(&p.buf[%d])) = p.%s\n\n",
			start, field.Name))

	case "int64":
		code.WriteString(fmt.Sprintf("\t*(*int64)(unsafe.Pointer(&p.buf[%d])) = p.%s\n\n",
			start, field.Name))

	default:
		if strings.HasPrefix(field.GoType, "[") && strings.Contains(field.GoType, "]byte") {
			code.WriteString(fmt.Sprintf("\tcopy(p.buf[%d:%d], p.%s[:])\n\n", start, end, field.Name))
		} else {
			code.WriteString(fmt.Sprintf("\t// TODO: zerocopy marshal %s\n\n", field.GoType))
		}
	}

	return code.String()
}

// generateZeroCopyDynamicMarshal generates marshal code for dynamic field into p.buf
func (g *Generator) generateZeroCopyDynamicMarshal(region analyzer.Region) string {
	var code strings.Builder

	field := region.Field
	start := region.Start
	boundary := region.Boundary
	countField := field.Layout.CountField

	// Only handle []byte for now
	if field.GoType != "[]byte" {
		code.WriteString(fmt.Sprintf("\t// TODO: zerocopy marshal dynamic %s\n\n", field.GoType))
		return code.String()
	}

	// Comment
	if countField != "" {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d) with count=%s\n",
			field.Name, field.GoType, start, boundary, countField))
	} else {
		code.WriteString(fmt.Sprintf("\t// %s: %s at [%d, %d)\n",
			field.Name, field.GoType, start, boundary))
	}

	// Since Body is a slice into p.buf[], it's already in the right place.
	// But we might need to copy if it was modified.
	// For now, just note that fields should reference p.buf directly.
	code.WriteString(fmt.Sprintf("\t// %s is already sliced from p.buf, no copy needed\n\n", field.Name))

	return code.String()
}
