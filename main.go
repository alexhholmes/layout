package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/alexhholmes/layout/internal/analyzer"
	"github.com/alexhholmes/layout/internal/codegen"
	"github.com/alexhholmes/layout/internal/parser"
)

func main() {
	if len(os.Args) < 3 {
		fmt.Fprintf(os.Stderr, "Usage: layout generate <file.go>\n")
		os.Exit(1)
	}

	cmd := os.Args[1]
	if cmd != "generate" {
		fmt.Fprintf(os.Stderr, "Unknown command: %s\n", cmd)
		fmt.Fprintf(os.Stderr, "Available commands: generate\n")
		os.Exit(1)
	}

	inputFile := os.Args[2]
	if err := generate(inputFile); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func generate(inputFile string) error {
	// Parse input file
	layouts, aliases, err := parser.ParseFile(inputFile)
	if err != nil {
		return fmt.Errorf("parse failed: %w", err)
	}

	if len(layouts) == 0 {
		return fmt.Errorf("no types with @layout annotations found in %s", inputFile)
	}

	// Build output filename: page.go -> page_layout.go
	outputFile := generateOutputFilename(inputFile)

	// Analyze and generate for all types
	registry := analyzer.NewTypeRegistry()

	// Register type aliases
	for alias, underlying := range aliases {
		registry.RegisterAlias(alias, underlying)
	}

	// First pass: register all types in the registry
	for _, layout := range layouts {
		registry.Register(layout.Name, layout.Anno.Size)
	}

	var generated strings.Builder

	// File header
	generated.WriteString("// Code generated by layout. DO NOT EDIT.\n\n")

	// Determine package from first layout (all should be same package)
	packageName := extractPackageName(inputFile)
	generated.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Check if any type uses zerocopy mode or has allocator
	needsUnsafe := false
	needsBinary := false
	needsFmt := false
	for _, layout := range layouts {
		if layout.Anno.Mode == "zerocopy" {
			needsUnsafe = true
			// Need fmt for panic in custom allocator validation
			if layout.Anno.Allocator != "" {
				needsFmt = true
			}
		} else {
			needsBinary = true
		}
	}

	// Imports
	generated.WriteString("import (\n")
	if needsBinary {
		generated.WriteString("\t\"encoding/binary\"\n")
		generated.WriteString("\t\"fmt\"\n")
	}
	if needsUnsafe {
		if needsFmt && !needsBinary {
			generated.WriteString("\t\"fmt\"\n")
		}
		generated.WriteString("\t\"io\"\n")
		generated.WriteString("\t\"unsafe\"\n")
	}
	generated.WriteString(")\n\n")

	// Second pass: generate code for each type
	generatedTypes := []string{}
	for _, layout := range layouts {
		analyzed, err := analyzer.Analyze(layout, registry)
		if err != nil {
			// Print detailed errors for debugging
			if analyzed != nil && len(analyzed.Errors) > 0 {
				for _, e := range analyzed.Errors {
					fmt.Fprintf(os.Stderr, "  Error: %s\n", e)
				}
			}
			return fmt.Errorf("analyze %s: %w", layout.Name, err)
		}

		if !analyzed.IsValid() {
			return fmt.Errorf("layout %s invalid: %v", layout.Name, analyzed.Errors)
		}

		endian := "little"
		if layout.Anno.Endian != "" {
			endian = layout.Anno.Endian
		}

		mode := "copy"
		if layout.Anno.Mode != "" {
			mode = layout.Anno.Mode
		}

		align := layout.Anno.Align
		allocator := layout.Anno.Allocator

		gen := codegen.NewGenerator(analyzed, layout, layouts, registry, endian, mode, align, allocator)

		// Generate marshal
		marshal := gen.GenerateMarshal()
		generated.WriteString(marshal)
		generated.WriteString("\n")

		// Generate unmarshal
		unmarshal := gen.GenerateUnmarshal()
		generated.WriteString(unmarshal)
		generated.WriteString("\n")

		generatedTypes = append(generatedTypes, layout.Name)
	}

	// Write output file
	if err := os.WriteFile(outputFile, []byte(generated.String()), 0644); err != nil {
		return fmt.Errorf("write output: %w", err)
	}

	// Success message
	fmt.Printf("Generated: %s\n", outputFile)
	for _, typeName := range generatedTypes {
		fmt.Printf("  - %s.MarshalLayout() ([]byte, error)\n", typeName)
		fmt.Printf("  - %s.UnmarshalLayout([]byte) error\n", typeName)
	}

	return nil
}

func generateOutputFilename(inputFile string) string {
	dir := filepath.Dir(inputFile)
	base := filepath.Base(inputFile)
	ext := filepath.Ext(base)
	nameWithoutExt := strings.TrimSuffix(base, ext)

	outputBase := nameWithoutExt + "_layout.go"
	return filepath.Join(dir, outputBase)
}

func extractPackageName(inputFile string) string {
	// Quick and dirty: read first line that starts with "package"
	data, err := os.ReadFile(inputFile)
	if err != nil {
		return "main"
	}

	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "package ") {
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				return parts[1]
			}
		}
	}

	return "main"
}
