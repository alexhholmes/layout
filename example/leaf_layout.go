// Code generated by layout. DO NOT EDIT.

package example

import (
	"encoding/binary"
	"fmt"
)

func (p *LeafElement) MarshalLayout() ([]byte, error) {
	buf := make([]byte, 8)

	// Key: uint32 at [0, 4)
	binary.LittleEndian.PutUint32(buf[0:4], p.Key)

	// Offset: uint32 at [4, 8)
	binary.LittleEndian.PutUint32(buf[4:8], p.Offset)

	return buf, nil
}

func (p *LeafElement) UnmarshalLayout(buf []byte) error {
	if len(buf) != 8 {
		return fmt.Errorf("expected 8 bytes, got %d", len(buf))
	}

	// Key: uint32 at [0, 4)
	p.Key = binary.LittleEndian.Uint32(buf[0:4])

	// Offset: uint32 at [4, 8)
	p.Offset = binary.LittleEndian.Uint32(buf[4:8])

	return nil
}

func (p *LeafHeader) MarshalLayout() ([]byte, error) {
	buf := make([]byte, 16)

	// NumKeys: uint16 at [0, 2)
	binary.LittleEndian.PutUint16(buf[0:2], p.NumKeys)

	// Flags: uint16 at [2, 4)
	binary.LittleEndian.PutUint16(buf[2:4], p.Flags)

	// NextPage: uint32 at [4, 8)
	binary.LittleEndian.PutUint32(buf[4:8], p.NextPage)

	// PrevPage: uint32 at [8, 12)
	binary.LittleEndian.PutUint32(buf[8:12], p.PrevPage)

	// Reserved: uint32 at [12, 16)
	binary.LittleEndian.PutUint32(buf[12:16], p.Reserved)

	return buf, nil
}

func (p *LeafHeader) UnmarshalLayout(buf []byte) error {
	if len(buf) != 16 {
		return fmt.Errorf("expected 16 bytes, got %d", len(buf))
	}

	// NumKeys: uint16 at [0, 2)
	p.NumKeys = binary.LittleEndian.Uint16(buf[0:2])

	// Flags: uint16 at [2, 4)
	p.Flags = binary.LittleEndian.Uint16(buf[2:4])

	// NextPage: uint32 at [4, 8)
	p.NextPage = binary.LittleEndian.Uint32(buf[4:8])

	// PrevPage: uint32 at [8, 12)
	p.PrevPage = binary.LittleEndian.Uint32(buf[8:12])

	// Reserved: uint32 at [12, 16)
	p.Reserved = binary.LittleEndian.Uint32(buf[12:16])

	return nil
}

func (p *LeafNode) MarshalLayout() ([]byte, error) {
	buf := make([]byte, 4096)
	var offset int

	// Header: LeafHeader at [0, 16)
	elemBuf, err := p.Header.MarshalLayout()
	if err != nil {
		return nil, fmt.Errorf("marshal Header: %w", err)
	}
	copy(buf[0:16], elemBuf)

	// Elements: []LeafElement at [16, 4088) with count=Header.NumKeys (element size: 8)
	offset = 16
	if len(p.Elements) != int(p.Header.NumKeys) {
		return nil, fmt.Errorf("Elements length mismatch: have %d, want %d", len(p.Elements), p.Header.NumKeys)
	}
	for i := range p.Elements {
		if offset + 8 > 4088 {
			return nil, fmt.Errorf("Elements collision at offset %d", offset)
		}
		elemBuf, err := p.Elements[i].MarshalLayout()
		if err != nil {
			return nil, fmt.Errorf("marshal Elements[%d]: %w", i, err)
		}
		copy(buf[offset:offset+8], elemBuf)
		offset += 8
	}

	// Footer: uint64 at [4088, 4096)
	binary.LittleEndian.PutUint64(buf[4088:4096], p.Footer)

	return buf, nil
}

func (p *LeafNode) UnmarshalLayout(buf []byte) error {
	if len(buf) != 4096 {
		return fmt.Errorf("expected 4096 bytes, got %d", len(buf))
	}

	// Header: LeafHeader at [0, 16)
	if err := p.Header.UnmarshalLayout(buf[0:16]); err != nil {
		return fmt.Errorf("unmarshal Header: %w", err)
	}

	// Elements: []LeafElement at [16, 4088) with count=Header.NumKeys (element size: 8)
	// Reuse slice if capacity allows
	if cap(p.Elements) >= int(p.Header.NumKeys) {
		p.Elements = p.Elements[:p.Header.NumKeys]
	} else {
		p.Elements = make([]LeafElement, p.Header.NumKeys)
	}
	offset := 16
	for i := range p.Elements {
		if err := p.Elements[i].UnmarshalLayout(buf[offset:offset+8]); err != nil {
			return fmt.Errorf("unmarshal Elements[%d]: %w", i, err)
		}
		offset += 8
	}

	// Footer: uint64 at [4088, 4096)
	p.Footer = binary.LittleEndian.Uint64(buf[4088:4096])

	return nil
}

